{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SIMPLOO","text":"<p>Simple Lua Object Orientation - A library that brings class-based object-oriented programming to Lua.</p>"},{"location":"#what-is-simploo","title":"What is SIMPLOO?","text":"<p>Lua is a prototype-based language, which makes traditional OOP patterns like inheritance and encapsulation difficult to implement. SIMPLOO provides a familiar class syntax that handles all the complexity for you.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Class definitions with a clean, readable syntax</li> <li>Access modifiers - <code>public</code>, <code>private</code>, <code>static</code>, <code>const</code>, and more</li> <li>Multiple inheritance - extend from one or more parent classes</li> <li>Constructors and finalizers - <code>__construct</code> and <code>__finalize</code> lifecycle methods</li> <li>Metamethods - define <code>__tostring</code>, <code>__call</code>, <code>__add</code>, and others</li> <li>Namespaces - organize classes with <code>namespace</code> and <code>using</code></li> <li>Serialization - save and restore instance state</li> <li>Two syntax styles - choose what fits your coding style</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<p>SIMPLOO supports two syntax styles. Use whichever you prefer:</p> Block SyntaxBuilder Syntax <pre><code>dofile(\"simploo.lua\")\n\nclass \"Player\" {\n    name = \"Unknown\";\n    health = 100;\n\n    __construct = function(self, playerName)\n        self.name = playerName\n    end;\n\n    takeDamage = function(self, amount)\n        self.health = self.health - amount\n        print(self.name .. \" has \" .. self.health .. \" health\")\n    end;\n}\n\nlocal player = Player.new(\"Alice\")\nplayer:takeDamage(25)  -- Alice has 75 health\n</code></pre> <pre><code>dofile(\"simploo.lua\")\n\nlocal player = class(\"Player\")\nplayer.name = \"Unknown\"\nplayer.health = 100\n\nfunction player:__construct(playerName)\n    self.name = playerName\nend\n\nfunction player:takeDamage(amount)\n    self.health = self.health - amount\n    print(self.name .. \" has \" .. self.health .. \" health\")\nend\n\nplayer:register()\n\nlocal p = Player.new(\"Alice\")\np:takeDamage(25)  -- Alice has 75 health\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Lua 5.1, Lua 5.2, or LuaJIT</li> <li>For Lua 5.2: the <code>debug</code> library is required for the <code>using</code> keyword</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and your first class</li> <li>Guide - Learn the fundamentals</li> <li>Reference - Complete API reference</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you install SIMPLOO and create your first class.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<ol> <li>Download <code>simploo.lua</code> from the releases page or build it from source</li> <li>Place the file in your project directory</li> <li>Load it at the start of your program:</li> </ol> <pre><code>dofile(\"simploo.lua\")\n</code></pre> <p>Or if you're using <code>require</code>:</p> <pre><code>require(\"simploo\")\n</code></pre>"},{"location":"getting-started/#your-first-class","title":"Your First Class","text":"<p>Let's create a simple <code>Counter</code> class that can increment and display a value.</p> Block SyntaxBuilder Syntax <pre><code>dofile(\"simploo.lua\")\n\nclass \"Counter\" {\n    value = 0;\n\n    increment = function(self)\n        self.value = self.value + 1\n    end;\n\n    print = function(self)\n        print(\"Count: \" .. self.value)\n    end;\n}\n</code></pre> <pre><code>dofile(\"simploo.lua\")\n\nlocal counter = class(\"Counter\")\ncounter.value = 0\n\nfunction counter:increment()\n    self.value = self.value + 1\nend\n\nfunction counter:print()\n    print(\"Count: \" .. self.value)\nend\n\ncounter:register()\n</code></pre>"},{"location":"getting-started/#creating-instances","title":"Creating Instances","text":"<p>Once a class is defined, create instances using <code>.new()</code>:</p> <pre><code>local myCounter = Counter.new()\n\nmyCounter:increment()\nmyCounter:increment()\nmyCounter:increment()\nmyCounter:print()  -- Count: 3\n</code></pre> <p>Each instance has its own copy of the class members:</p> <pre><code>local counter1 = Counter.new()\nlocal counter2 = Counter.new()\n\ncounter1:increment()\ncounter1:increment()\n\ncounter1:print()  -- Count: 2\ncounter2:print()  -- Count: 0\n</code></pre>"},{"location":"getting-started/#adding-a-constructor","title":"Adding a Constructor","text":"<p>Use <code>__construct</code> to initialize instances with custom values:</p> Block SyntaxBuilder Syntax <pre><code>class \"Counter\" {\n    value = 0;\n\n    __construct = function(self, startValue)\n        self.value = startValue or 0\n    end;\n\n    increment = function(self)\n        self.value = self.value + 1\n    end;\n\n    print = function(self)\n        print(\"Count: \" .. self.value)\n    end;\n}\n</code></pre> <pre><code>local counter = class(\"Counter\")\ncounter.value = 0\n\nfunction counter:__construct(startValue)\n    self.value = startValue or 0\nend\n\nfunction counter:increment()\n    self.value = self.value + 1\nend\n\nfunction counter:print()\n    print(\"Count: \" .. self.value)\nend\n\ncounter:register()\n</code></pre> <p>Now you can pass arguments when creating instances:</p> <pre><code>local myCounter = Counter.new(10)\nmyCounter:increment()\nmyCounter:print()  -- Count: 11\n</code></pre>"},{"location":"getting-started/#development-vs-production-mode","title":"Development vs Production Mode","text":"<p>SIMPLOO has two modes:</p> <ul> <li>Development mode (default) - Includes safety checks like private member access enforcement</li> <li>Production mode - Disables checks for better performance</li> </ul> <p>Set the mode before loading simploo:</p> <pre><code>simploo = {config = {}}\nsimploo.config[\"production\"] = true\ndofile(\"simploo.lua\")\n</code></pre> <p>See Configuration for all available options.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Classes - Learn both syntax styles in detail</li> <li>Members - Variables and methods</li> <li>Constructors - Initialization and cleanup</li> <li>Modifiers - Add <code>private</code>, <code>static</code>, and more</li> </ul>"},{"location":"features/hotswap/","title":"Hotswap","text":"<p>Hotswap allows you to update class definitions at runtime, automatically updating existing instances with new members.</p>"},{"location":"features/hotswap/#enabling-hotswap","title":"Enabling Hotswap","text":"<p>Enable hotswap before loading any classes:</p> <pre><code>simploo.config[\"classHotswap\"] = true\ndofile(\"simploo.lua\")\n</code></pre> <p>Or initialize it manually:</p> <pre><code>dofile(\"simploo.lua\")\nsimploo.hotswap:init()\n</code></pre>"},{"location":"features/hotswap/#how-it-works","title":"How It Works","text":"<p>When you redefine a class, existing instances are updated:</p> <ul> <li>New members are added to existing instances</li> <li>Removed members are deleted from existing instances</li> <li>Existing member values are preserved</li> </ul> <pre><code>-- Initial definition\nclass \"Player\" {\n    name = \"\";\n    health = 100;\n}\n\nlocal player = Player.new()\nplayer.name = \"Alice\"\nplayer.health = 75\n\n-- Redefine the class\nclass \"Player\" {\n    name = \"\";\n    health = 100;\n    mana = 50;  -- New member added\n    -- 'destroy' was removed\n}\n\n-- Existing instance is updated\nprint(player.name)    -- Alice (preserved)\nprint(player.health)  -- 75 (preserved)\nprint(player.mana)    -- 50 (new member with default value)\n</code></pre>"},{"location":"features/hotswap/#what-gets-updated","title":"What Gets Updated","text":"Updated Not Updated New members added Existing values Removed members deleted Modified instance data Method implementations Default values for existing members Default values for new members"},{"location":"features/hotswap/#use-case-development","title":"Use Case: Development","text":"<p>Hotswap is useful during development when you want to iterate quickly:</p> <pre><code>-- Enable hotswap for development\nsimploo.config[\"classHotswap\"] = true\n\n-- Your game loop\nwhile running do\n    -- Check if source files changed\n    if filesChanged() then\n        -- Reload class definitions\n        dofile(\"classes/player.lua\")\n        dofile(\"classes/enemy.lua\")\n        -- Existing instances automatically get new members!\n    end\n\n    updateGame()\n    renderGame()\nend\n</code></pre>"},{"location":"features/hotswap/#limitations","title":"Limitations","text":"<ol> <li>Values are not updated: If you change a default value, existing instances keep their old values</li> <li>Memory overhead: Hotswap tracks all instances, using more memory</li> <li>Performance: Slight overhead on instance creation</li> </ol> <pre><code>class \"Example\" {\n    value = 10;\n}\n\nlocal e = Example.new()\nprint(e.value)  -- 10\n\n-- Redefine with new default\nclass \"Example\" {\n    value = 999;  -- Changed default\n}\n\nprint(e.value)  -- Still 10, not 999\n</code></pre>"},{"location":"features/hotswap/#memory-considerations","title":"Memory Considerations","text":"<p>Hotswap uses weak references, so instances can still be garbage collected:</p> <pre><code>simploo.config[\"classHotswap\"] = true\n\nclass \"Temp\" {}\n\nlocal t = Temp.new()\n-- t is tracked for hotswap\n\nt = nil\ncollectgarbage()\n-- t is garbage collected despite hotswap tracking\n</code></pre>"},{"location":"features/hotswap/#disabling-hotswap","title":"Disabling Hotswap","text":"<p>For production, disable hotswap to improve performance:</p> <pre><code>simploo.config[\"classHotswap\"] = false\nsimploo.config[\"production\"] = true\n</code></pre>"},{"location":"features/hotswap/#complete-example","title":"Complete Example","text":"<pre><code>simploo.config[\"classHotswap\"] = true\ndofile(\"simploo.lua\")\n\n-- Initial class\nclass \"Character\" {\n    name = \"\";\n    health = 100;\n\n    takeDamage = function(self, amount)\n        self.health = self.health - amount\n    end;\n}\n\n-- Create some instances\nlocal hero = Character.new()\nhero.name = \"Hero\"\nhero.health = 50\n\nlocal villain = Character.new()\nvillain.name = \"Villain\"\nvillain.health = 80\n\n-- Later, redefine the class with a new feature\nclass \"Character\" {\n    name = \"\";\n    health = 100;\n    shield = 0;  -- New!\n\n    takeDamage = function(self, amount)\n        local absorbed = math.min(self.shield, amount)\n        self.shield = self.shield - absorbed\n        self.health = self.health - (amount - absorbed)\n    end;\n}\n\n-- Existing instances now have shield\nprint(hero.shield)     -- 0 (new member with default)\nprint(villain.shield)  -- 0 (new member with default)\n\n-- Existing values preserved\nprint(hero.name)       -- Hero\nprint(hero.health)     -- 50\nprint(villain.name)    -- Villain\nprint(villain.health)  -- 80\n</code></pre>"},{"location":"features/metamethods/","title":"Metamethods","text":"<p>Metamethods let you customize how instances behave with Lua operators and built-in functions.</p>"},{"location":"features/metamethods/#using-the-meta-modifier","title":"Using the <code>meta</code> Modifier","text":"<p>Mark metamethods with the <code>meta</code> modifier:</p> Block SyntaxBuilder Syntax <pre><code>class \"Vector\" {\n    x = 0;\n    y = 0;\n\n    meta {\n        __tostring = function(self)\n            return \"(\" .. self.x .. \", \" .. self.y .. \")\"\n        end;\n    };\n}\n</code></pre> <pre><code>local vec = class(\"Vector\")\nvec.x = 0\nvec.y = 0\n\nfunction vec.meta:__tostring()\n    return \"(\" .. self.x .. \", \" .. self.y .. \")\"\nend\n\nvec:register()\n</code></pre>"},{"location":"features/metamethods/#supported-metamethods","title":"Supported Metamethods","text":"Metamethod Triggered by <code>__tostring</code> <code>tostring(obj)</code> or <code>print(obj)</code> <code>__call</code> <code>obj()</code> <code>__index</code> <code>obj.unknownKey</code> <code>__newindex</code> <code>obj.unknownKey = value</code> <code>__concat</code> <code>obj .. other</code> <code>__unm</code> <code>-obj</code> <code>__add</code> <code>obj + other</code> <code>__sub</code> <code>obj - other</code> <code>__mul</code> <code>obj * other</code> <code>__div</code> <code>obj / other</code> <code>__mod</code> <code>obj % other</code> <code>__pow</code> <code>obj ^ other</code> <code>__eq</code> <code>obj == other</code> <code>__lt</code> <code>obj &lt; other</code> <code>__le</code> <code>obj &lt;= other</code>"},{"location":"features/metamethods/#__tostring","title":"__tostring","text":"<p>Customize string representation:</p> Block SyntaxBuilder Syntax <pre><code>class \"Person\" {\n    name = \"\";\n    age = 0;\n\n    __construct = function(self, name, age)\n        self.name = name\n        self.age = age\n    end;\n\n    meta {\n        __tostring = function(self)\n            return self.name .. \" (age \" .. self.age .. \")\"\n        end;\n    };\n}\n</code></pre> <pre><code>local person = class(\"Person\")\nperson.name = \"\"\nperson.age = 0\n\nfunction person:__construct(name, age)\n    self.name = name\n    self.age = age\nend\n\nfunction person.meta:__tostring()\n    return self.name .. \" (age \" .. self.age .. \")\"\nend\n\nperson:register()\n</code></pre> <pre><code>local p = Person.new(\"Alice\", 30)\nprint(p)  -- Alice (age 30)\n</code></pre>"},{"location":"features/metamethods/#__call","title":"__call","text":"<p>Make instances callable like functions:</p> Block SyntaxBuilder Syntax <pre><code>class \"Multiplier\" {\n    factor = 1;\n\n    __construct = function(self, f)\n        self.factor = f\n    end;\n\n    meta {\n        __call = function(self, value)\n            return value * self.factor\n        end;\n    };\n}\n</code></pre> <pre><code>local mult = class(\"Multiplier\")\nmult.factor = 1\n\nfunction mult:__construct(f)\n    self.factor = f\nend\n\nfunction mult.meta:__call(value)\n    return value * self.factor\nend\n\nmult:register()\n</code></pre> <pre><code>local double = Multiplier.new(2)\nlocal triple = Multiplier.new(3)\n\nprint(double(5))   -- 10\nprint(triple(5))   -- 15\n</code></pre> <p>__construct vs __call</p> <p>The first call to an instance uses <code>__construct</code>. Subsequent calls use <code>__call</code>:</p> <pre><code>local m = Multiplier(2)  -- calls __construct\nprint(m(5))              -- calls __call, prints 10\n</code></pre>"},{"location":"features/metamethods/#arithmetic-operators","title":"Arithmetic Operators","text":"<p>Implement mathematical operations:</p> <pre><code>class \"Complex\" {\n    real = 0;\n    imag = 0;\n\n    __construct = function(self, r, i)\n        self.real = r or 0\n        self.imag = i or 0\n    end;\n\n    meta {\n        __add = function(self, other)\n            return Complex.new(\n                self.real + other.real,\n                self.imag + other.imag\n            )\n        end;\n\n        __sub = function(self, other)\n            return Complex.new(\n                self.real - other.real,\n                self.imag - other.imag\n            )\n        end;\n\n        __mul = function(self, other)\n            return Complex.new(\n                self.real * other.real - self.imag * other.imag,\n                self.real * other.imag + self.imag * other.real\n            )\n        end;\n\n        __unm = function(self)\n            return Complex.new(-self.real, -self.imag)\n        end;\n\n        __tostring = function(self)\n            if self.imag &gt;= 0 then\n                return self.real .. \"+\" .. self.imag .. \"i\"\n            else\n                return self.real .. self.imag .. \"i\"\n            end\n        end;\n    };\n}\n\nlocal a = Complex.new(3, 2)\nlocal b = Complex.new(1, 4)\n\nprint(a + b)  -- 4+6i\nprint(a - b)  -- 2-2i\nprint(a * b)  -- -5+14i\nprint(-a)     -- -3-2i\n</code></pre>"},{"location":"features/metamethods/#comparison-operators","title":"Comparison Operators","text":"<pre><code>class \"Version\" {\n    major = 0;\n    minor = 0;\n    patch = 0;\n\n    __construct = function(self, maj, min, pat)\n        self.major = maj or 0\n        self.minor = min or 0\n        self.patch = pat or 0\n    end;\n\n    meta {\n        __eq = function(self, other)\n            return self.major == other.major\n                and self.minor == other.minor\n                and self.patch == other.patch\n        end;\n\n        __lt = function(self, other)\n            if self.major ~= other.major then\n                return self.major &lt; other.major\n            end\n            if self.minor ~= other.minor then\n                return self.minor &lt; other.minor\n            end\n            return self.patch &lt; other.patch\n        end;\n\n        __le = function(self, other)\n            return self == other or self &lt; other\n        end;\n\n        __tostring = function(self)\n            return self.major .. \".\" .. self.minor .. \".\" .. self.patch\n        end;\n    };\n}\n\nlocal v1 = Version.new(1, 0, 0)\nlocal v2 = Version.new(1, 2, 0)\nlocal v3 = Version.new(1, 2, 0)\n\nprint(v1 &lt; v2)   -- true\nprint(v2 == v3)  -- true\nprint(v2 &lt;= v3)  -- true\n</code></pre>"},{"location":"features/metamethods/#__index-and-__newindex","title":"__index and __newindex","text":"<p>Handle access to undefined members:</p> <pre><code>class \"FlexibleObject\" {\n    data = {};\n\n    meta {\n        __index = function(self, key)\n            return self.data[key]\n        end;\n\n        __newindex = function(self, key, value)\n            print(\"Setting \" .. key .. \" = \" .. tostring(value))\n            self.data[key] = value\n        end;\n    };\n}\n\nlocal obj = FlexibleObject.new()\nobj.foo = 42       -- Setting foo = 42\nobj.bar = \"hello\"  -- Setting bar = hello\nprint(obj.foo)     -- 42\nprint(obj.bar)     -- hello\n</code></pre>"},{"location":"features/metamethods/#__concat","title":"__concat","text":"<p>Implement string concatenation:</p> <pre><code>class \"StringBuilder\" {\n    parts = {};\n\n    add = function(self, str)\n        table.insert(self.parts, str)\n        return self\n    end;\n\n    meta {\n        __concat = function(self, other)\n            local new = StringBuilder.new()\n            for _, p in ipairs(self.parts) do\n                table.insert(new.parts, p)\n            end\n            if type(other) == \"string\" then\n                table.insert(new.parts, other)\n            else\n                for _, p in ipairs(other.parts) do\n                    table.insert(new.parts, p)\n                end\n            end\n            return new\n        end;\n\n        __tostring = function(self)\n            return table.concat(self.parts)\n        end;\n    };\n}\n\nlocal a = StringBuilder.new():add(\"Hello\"):add(\" \")\nlocal b = StringBuilder.new():add(\"World\"):add(\"!\")\n\nprint(a .. b)  -- Hello World!\n</code></pre>"},{"location":"features/metamethods/#multiple-metamethods-example","title":"Multiple Metamethods Example","text":"<pre><code>class \"Money\" {\n    cents = 0;\n\n    __construct = function(self, dollars, cents)\n        self.cents = (dollars or 0) * 100 + (cents or 0)\n    end;\n\n    meta {\n        __add = function(self, other)\n            local m = Money.new()\n            m.cents = self.cents + other.cents\n            return m\n        end;\n\n        __sub = function(self, other)\n            local m = Money.new()\n            m.cents = self.cents - other.cents\n            return m\n        end;\n\n        __mul = function(self, factor)\n            local m = Money.new()\n            m.cents = math.floor(self.cents * factor)\n            return m\n        end;\n\n        __eq = function(self, other)\n            return self.cents == other.cents\n        end;\n\n        __lt = function(self, other)\n            return self.cents &lt; other.cents\n        end;\n\n        __tostring = function(self)\n            local dollars = math.floor(self.cents / 100)\n            local cents = self.cents % 100\n            return string.format(\"$%d.%02d\", dollars, cents)\n        end;\n    };\n}\n\nlocal price = Money.new(10, 50)   -- $10.50\nlocal tax = Money.new(0, 84)      -- $0.84\nlocal total = price + tax         -- $11.34\nlocal discounted = total * 0.9    -- $10.20\n\nprint(price)      -- $10.50\nprint(total)      -- $11.34\nprint(discounted) -- $10.20\nprint(price &lt; total)  -- true\n</code></pre>"},{"location":"features/serialization/","title":"Serialization","text":"<p>Serialization converts instances to data that can be saved, and deserialization restores them.</p>"},{"location":"features/serialization/#basic-serialization","title":"Basic Serialization","text":"<p>Use <code>simploo.serialize()</code> to convert an instance to a table:</p> <pre><code>class \"Player\" {\n    name = \"\";\n    level = 1;\n    score = 0;\n}\n\nlocal player = Player.new()\nplayer.name = \"Alice\"\nplayer.level = 10\nplayer.score = 5000\n\nlocal data = simploo.serialize(player)\n\n-- data is now a plain Lua table:\n-- {\n--     Player = {\n--         name = \"Alice\",\n--         level = 10,\n--         score = 5000\n--     }\n-- }\n</code></pre>"},{"location":"features/serialization/#basic-deserialization","title":"Basic Deserialization","text":"<p>Use <code>simploo.deserialize()</code> to restore an instance from data:</p> <pre><code>-- Restore from data\nlocal restored = simploo.deserialize(data)\n\nprint(restored.name)   -- Alice\nprint(restored.level)  -- 10\nprint(restored.score)  -- 5000\n\n-- It's a real instance\nprint(restored:get_name())  -- Player\n</code></pre>"},{"location":"features/serialization/#saving-and-loading","title":"Saving and Loading","text":"<p>Combine with file I/O or JSON libraries:</p> <pre><code>class \"GameState\" {\n    playerName = \"\";\n    level = 1;\n    checkpoints = {};\n}\n\n-- Save\nlocal function saveGame(state, filename)\n    local data = simploo.serialize(state)\n    -- Use your preferred serialization (JSON, MessagePack, etc.)\n    local json = require(\"json\")\n    local file = io.open(filename, \"w\")\n    file:write(json.encode(data))\n    file:close()\nend\n\n-- Load\nlocal function loadGame(filename)\n    local json = require(\"json\")\n    local file = io.open(filename, \"r\")\n    local content = file:read(\"*all\")\n    file:close()\n    local data = json.decode(content)\n    return simploo.deserialize(data)\nend\n</code></pre>"},{"location":"features/serialization/#excluding-members-with-transient","title":"Excluding Members with <code>transient</code>","text":"<p>Members marked <code>transient</code> are not serialized:</p> Block SyntaxBuilder Syntax <pre><code>class \"Connection\" {\n    -- Serialized\n    serverAddress = \"\";\n    port = 8080;\n\n    transient {\n        -- Not serialized\n        socket = null;\n        lastPing = 0;\n        isConnected = false;\n    };\n}\n</code></pre> <pre><code>local conn = class(\"Connection\")\n-- Serialized\nconn.serverAddress = \"\"\nconn.port = 8080\n-- Not serialized\nconn.transient.socket = null\nconn.transient.lastPing = 0\nconn.transient.isConnected = false\nconn:register()\n</code></pre>"},{"location":"features/serialization/#serializing-inheritance","title":"Serializing Inheritance","text":"<p>Parent class data is serialized under the parent's name:</p> <pre><code>class \"Entity\" {\n    id = 0;\n    position = {x = 0, y = 0};\n}\n\nclass \"Player\" extends \"Entity\" {\n    name = \"\";\n    health = 100;\n}\n\nlocal player = Player.new()\nplayer.id = 42\nplayer.position = {x = 10, y = 20}\nplayer.name = \"Alice\"\nplayer.health = 75\n\nlocal data = simploo.serialize(player)\n-- {\n--     Player = {\n--         name = \"Alice\",\n--         health = 75,\n--         Entity = {\n--             id = 42,\n--             position = {x = 10, y = 20}\n--         }\n--     }\n-- }\n\nlocal restored = simploo.deserialize(data)\nprint(restored.name)       -- Alice\nprint(restored.id)         -- 42\nprint(restored.position.x) -- 10\n</code></pre>"},{"location":"features/serialization/#instance-deserialize-method","title":"Instance deserialize() Method","text":"<p>You can also deserialize into an existing class:</p> <pre><code>class \"Config\" {\n    debug = false;\n    volume = 100;\n}\n\nlocal data = {\n    Config = {\n        debug = true,\n        volume = 50\n    }\n}\n\n-- Using class method\nlocal config = Config:deserialize(data)\n\nprint(config.debug)   -- true\nprint(config.volume)  -- 50\n</code></pre>"},{"location":"features/serialization/#cloning-instances","title":"Cloning Instances","text":"<p>Use <code>clone()</code> for fast in-memory copies. Unlike serialize/deserialize, clone includes transient members:</p> <pre><code>class \"Player\" {\n    name = \"\";\n    health = 100;\n\n    transient { sessionId = 0 };\n}\n\nlocal player = Player.new()\nplayer.name = \"Alice\"\nplayer.health = 75\nplayer.sessionId = 12345\n\n-- Clone copies everything, including transient\nlocal cloned = player:clone()\nprint(cloned.name)      -- Alice\nprint(cloned.sessionId) -- 12345 (preserved!)\n\n-- Clone is independent\ncloned.health = 100\nprint(player.health) -- 75 (unchanged)\n</code></pre>"},{"location":"features/serialization/#when-to-use-clone-vs-serialize","title":"When to Use clone() vs serialize()","text":"Use Case Method Save to file/database <code>serialize()</code> + <code>deserialize()</code> In-memory copy <code>clone()</code> Network transfer <code>serialize()</code> + <code>deserialize()</code> Undo/redo system <code>clone()</code> Object pooling <code>clone()</code>"},{"location":"features/serialization/#what-gets-serialized","title":"What Gets Serialized","text":"Serialized Not Serialized Public variables Functions/methods Private variables <code>transient</code> members Parent class data <code>static</code> members Tables and primitives Runtime-added members <p>Deserialization silently skips data for members that no longer exist on the class.</p>"},{"location":"features/serialization/#complete-example","title":"Complete Example","text":"<pre><code>class \"Character\" {\n    name = \"\";\n    level = 1;\n}\n\nclass \"Inventory\" {\n    items = {};\n    maxSlots = 20;\n\n    addItem = function(self, item)\n        if #self.items &lt; self.maxSlots then\n            table.insert(self.items, item)\n            return true\n        end\n        return false\n    end;\n}\n\nclass \"Player\" extends \"Character\" {\n    health = 100;\n    gold = 0;\n    inventory = null;\n\n    transient {\n        lastSaveTime = 0;\n        isDirty = false;\n    };\n\n    __construct = function(self, name)\n        self.name = name\n        self.inventory = Inventory.new()\n    end;\n}\n\n-- Create and modify\nlocal player = Player.new(\"Hero\")\nplayer.level = 15\nplayer.health = 85\nplayer.gold = 500\nplayer.inventory:addItem(\"Sword\")\nplayer.inventory:addItem(\"Potion\")\nplayer.lastSaveTime = os.time()\nplayer.isDirty = true\n\n-- Serialize\nlocal data = simploo.serialize(player)\n\n-- Save to file (pseudocode)\n-- saveToFile(\"save.dat\", data)\n\n-- Load from file (pseudocode)\n-- local data = loadFromFile(\"save.dat\")\n\n-- Deserialize\nlocal loaded = simploo.deserialize(data)\n\nprint(loaded.name)                -- Hero\nprint(loaded.level)               -- 15\nprint(loaded.gold)                -- 500\nprint(#loaded.inventory.items)    -- 2\nprint(loaded.lastSaveTime)        -- 0 (transient, reset to default)\nprint(loaded.isDirty)             -- false (transient, reset to default)\n</code></pre>"},{"location":"guide/access-control/","title":"Access Modifiers","text":"<p>Access modifiers control where class members can be accessed from.</p>"},{"location":"guide/access-control/#public","title":"Public","text":"<p><code>public</code> members can be accessed from anywhere - inside the class, outside the class, and from subclasses.</p> Block SyntaxBuilder Syntax <pre><code>class \"Player\" {\n    public {\n        name = \"Unknown\";\n        health = 100;\n\n        takeDamage = function(self, amount)\n            self.health = self.health - amount\n        end;\n    };\n}\n</code></pre> <pre><code>local player = class(\"Player\")\nplayer.public.name = \"Unknown\"\nplayer.public.health = 100\n\nfunction player.public:takeDamage(amount)\n    self.health = self.health - amount\nend\n\nplayer:register()\n</code></pre> <pre><code>local p = Player.new()\np.name = \"Alice\"       -- OK: public access\nprint(p.health)        -- OK: public access\np:takeDamage(25)       -- OK: public access\n</code></pre> <p>Implicit Public</p> <p>Members without any modifier are automatically <code>public</code>:</p> <pre><code>class \"Player\" {\n    name = \"Unknown\";  -- This is public\n}\n</code></pre>"},{"location":"guide/access-control/#protected","title":"Protected","text":"<p><code>protected</code> members can be accessed from within the class's own methods and from subclass methods.</p> Block SyntaxBuilder Syntax <pre><code>class \"Vehicle\" {\n    protected {\n        speed = 0;\n        maxSpeed = 100;\n    };\n\n    public {\n        accelerate = function(self, amount)\n            self.speed = math.min(self.speed + amount, self.maxSpeed)\n        end;\n\n        getSpeed = function(self)\n            return self.speed\n        end;\n    };\n}\n\nclass \"SportsCar\" extends \"Vehicle\" {\n    public {\n        __construct = function(self)\n            self.maxSpeed = 200  -- Can access parent's protected member\n        end;\n\n        turboBoost = function(self)\n            self.speed = self.maxSpeed  -- Can access parent's protected member\n        end;\n    };\n}\n</code></pre> <pre><code>local vehicle = class(\"Vehicle\")\nvehicle.protected.speed = 0\nvehicle.protected.maxSpeed = 100\n\nfunction vehicle.public:accelerate(amount)\n    self.speed = math.min(self.speed + amount, self.maxSpeed)\nend\n\nfunction vehicle.public:getSpeed()\n    return self.speed\nend\n\nvehicle:register()\n\nlocal sportsCar = class(\"SportsCar\", {extends = \"Vehicle\"})\n\nfunction sportsCar.public:__construct()\n    self.maxSpeed = 200  -- Can access parent's protected member\nend\n\nfunction sportsCar.public:turboBoost()\n    self.speed = self.maxSpeed  -- Can access parent's protected member\nend\n\nsportsCar:register()\n</code></pre> <pre><code>local car = SportsCar.new()\n\n-- Access through public methods works\ncar:accelerate(50)\nprint(car:getSpeed())  -- 50\n\ncar:turboBoost()\nprint(car:getSpeed())  -- 200\n\n-- Direct access to protected member fails\nprint(car.speed)  -- Error: accessing protected member speed\ncar.maxSpeed = 300  -- Error: accessing protected member maxSpeed\n</code></pre>"},{"location":"guide/access-control/#private","title":"Private","text":"<p><code>private</code> members can only be accessed from within the class's own methods. Unlike <code>protected</code>, subclasses cannot access private members.</p> Block SyntaxBuilder Syntax <pre><code>class \"BankAccount\" {\n    private {\n        balance = 0;\n    };\n\n    public {\n        deposit = function(self, amount)\n            if amount &gt; 0 then\n                self.balance = self.balance + amount\n            end\n        end;\n\n        withdraw = function(self, amount)\n            if amount &gt; 0 and amount &lt;= self.balance then\n                self.balance = self.balance - amount\n                return true\n            end\n            return false\n        end;\n\n        getBalance = function(self)\n            return self.balance\n        end;\n    };\n}\n</code></pre> <pre><code>local account = class(\"BankAccount\")\naccount.private.balance = 0\n\nfunction account.public:deposit(amount)\n    if amount &gt; 0 then\n        self.balance = self.balance + amount\n    end\nend\n\nfunction account.public:withdraw(amount)\n    if amount &gt; 0 and amount &lt;= self.balance then\n        self.balance = self.balance - amount\n        return true\n    end\n    return false\nend\n\nfunction account.public:getBalance()\n    return self.balance\nend\n\naccount:register()\n</code></pre> <pre><code>local account = BankAccount.new()\n\n-- Access through public methods works\naccount:deposit(100)\nprint(account:getBalance())  -- 100\n\n-- Direct access to private member fails\nprint(account.balance)  -- Error: accessing private member balance\naccount.balance = 1000  -- Error: accessing private member balance\n</code></pre>"},{"location":"guide/access-control/#private-method-access","title":"Private Method Access","text":"<p>Private methods can only be called from other methods in the same class:</p> Block SyntaxBuilder Syntax <pre><code>class \"Validator\" {\n    private {\n        isValidEmail = function(self, email)\n            return string.match(email, \"@\") ~= nil\n        end;\n\n        isValidAge = function(self, age)\n            return age &gt;= 0 and age &lt; 150\n        end;\n    };\n\n    public {\n        validate = function(self, email, age)\n            local emailOk = self:isValidEmail(email)\n            local ageOk = self:isValidAge(age)\n            return emailOk and ageOk\n        end;\n    };\n}\n</code></pre> <pre><code>local validator = class(\"Validator\")\n\nfunction validator.private:isValidEmail(email)\n    return string.match(email, \"@\") ~= nil\nend\n\nfunction validator.private:isValidAge(age)\n    return age &gt;= 0 and age &lt; 150\nend\n\nfunction validator.public:validate(email, age)\n    local emailOk = self:isValidEmail(email)\n    local ageOk = self:isValidAge(age)\n    return emailOk and ageOk\nend\n\nvalidator:register()\n</code></pre> <pre><code>local v = Validator.new()\n\n-- Public method works\nprint(v:validate(\"test@example.com\", 25))  -- true\n\n-- Private methods fail from outside\nv:isValidEmail(\"test\")  -- Error: accessing private member\n</code></pre>"},{"location":"guide/access-control/#nested-method-calls","title":"Nested Method Calls","text":"<p>Private access works through nested method calls:</p> <pre><code>class \"Example\" {\n    private {\n        secret = 42;\n    };\n\n    public {\n        outer = function(self)\n            return self:inner()\n        end;\n\n        inner = function(self)\n            return self.secret  -- OK: called from within class method\n        end;\n    };\n}\n\nlocal e = Example.new()\nprint(e:outer())  -- 42 (works because call chain starts from public method)\nprint(e.secret)   -- Error: accessing private member\n</code></pre>"},{"location":"guide/access-control/#cross-instance-access","title":"Cross-Instance Access","text":"<p>Access control is class-based, not instance-based. A method can access private members of any instance of the same class:</p> <pre><code>class \"Wallet\" {\n    private {\n        money = 0;\n    };\n\n    public {\n        __construct = function(self, amount)\n            self.money = amount\n        end;\n\n        transferFrom = function(self, other, amount)\n            -- Works! Same class can access other instance's private\n            local taken = math.min(other.money, amount)\n            other.money = other.money - taken\n            self.money = self.money + taken\n        end;\n    };\n}\n\nlocal wallet1 = Wallet.new(100)\nlocal wallet2 = Wallet.new(50)\n\nwallet1:transferFrom(wallet2, 30)\nprint(wallet1.money)  -- Error: outside code still cannot access\n</code></pre> <p>This matches Java, C++, C#, Kotlin, and most other OOP languages. It enables useful patterns like comparison methods, copy constructors, and object pooling.</p>"},{"location":"guide/access-control/#complete-example","title":"Complete Example","text":"Block SyntaxBuilder Syntax <pre><code>dofile(\"simploo.lua\")\n\nclass \"User\" {\n    private {\n        password = \"\";\n        loginAttempts = 0;\n    };\n\n    public {\n        username = \"\";\n\n        __construct = function(self, name, pass)\n            self.username = name\n            self.password = pass\n        end;\n\n        login = function(self, pass)\n            if self.password == pass then\n                self.loginAttempts = 0\n                print(\"Welcome, \" .. self.username)\n                return true\n            else\n                self.loginAttempts = self.loginAttempts + 1\n                print(\"Invalid password. Attempts: \" .. self.loginAttempts)\n                return false\n            end\n        end;\n\n        changePassword = function(self, oldPass, newPass)\n            if self.password == oldPass then\n                self.password = newPass\n                print(\"Password changed\")\n                return true\n            end\n            print(\"Wrong password\")\n            return false\n        end;\n    };\n}\n\nlocal user = User.new(\"alice\", \"secret123\")\n\nprint(user.username)     -- alice (public)\nprint(user.password)     -- Error: accessing private member\n\nuser:login(\"wrong\")      -- Invalid password. Attempts: 1\nuser:login(\"secret123\")  -- Welcome, alice\n\nuser:changePassword(\"secret123\", \"newpass\")  -- Password changed\n</code></pre> <pre><code>dofile(\"simploo.lua\")\n\nlocal user = class(\"User\")\nuser.private.password = \"\"\nuser.private.loginAttempts = 0\nuser.public.username = \"\"\n\nfunction user.public:__construct(name, pass)\n    self.username = name\n    self.password = pass\nend\n\nfunction user.public:login(pass)\n    if self.password == pass then\n        self.loginAttempts = 0\n        print(\"Welcome, \" .. self.username)\n        return true\n    else\n        self.loginAttempts = self.loginAttempts + 1\n        print(\"Invalid password. Attempts: \" .. self.loginAttempts)\n        return false\n    end\nend\n\nfunction user.public:changePassword(oldPass, newPass)\n    if self.password == oldPass then\n        self.password = newPass\n        print(\"Password changed\")\n        return true\n    end\n    print(\"Wrong password\")\n    return false\nend\n\nuser:register()\n\nlocal u = User.new(\"alice\", \"secret123\")\n\nprint(u.username)     -- alice (public)\nprint(u.password)     -- Error: accessing private member\n\nu:login(\"wrong\")      -- Invalid password. Attempts: 1\nu:login(\"secret123\")  -- Welcome, alice\n\nu:changePassword(\"secret123\", \"newpass\")  -- Password changed\n</code></pre>"},{"location":"guide/access-control/#private-vs-protected-in-inheritance","title":"Private vs Protected in Inheritance","text":"<p>The key difference between <code>private</code> and <code>protected</code> becomes clear with inheritance:</p> <pre><code>class \"Parent\" {\n    private   { privateVar = \"private\" };\n    protected { protectedVar = \"protected\" };\n\n    public {\n        getPrivate = function(self)\n            return self.privateVar\n        end;\n        getProtected = function(self)\n            return self.protectedVar\n        end;\n    };\n}\n\nclass \"Child\" extends \"Parent\" {\n    public {\n        tryAccessPrivate = function(self)\n            return self.privateVar  -- Error! Private is not accessible\n        end;\n        tryAccessProtected = function(self)\n            return self.protectedVar  -- OK! Protected is accessible\n        end;\n    };\n}\n\nlocal child = Child.new()\n\n-- Parent methods can access both\nprint(child:getPrivate())     -- \"private\"\nprint(child:getProtected())   -- \"protected\"\n\n-- Child can access protected but not private\nprint(child:tryAccessProtected())  -- \"protected\"\nprint(child:tryAccessPrivate())    -- Error: accessing private member\n</code></pre> Modifier Same Class Subclass Outside <code>public</code> Yes Yes Yes <code>protected</code> Yes Yes No <code>private</code> Yes No No <p>Production Mode</p> <p>Access modifier enforcement only works in development mode. In production mode (<code>simploo.config[\"production\"] = true</code>), access checks are disabled for performance. See Configuration.</p>"},{"location":"guide/classes/","title":"Classes","text":"<p>SIMPLOO provides two syntax styles for defining classes. Both produce identical results - choose whichever fits your coding style.</p>"},{"location":"guide/classes/#block-syntax","title":"Block Syntax","text":"<p>The Block syntax uses a table-like structure that resembles class definitions in other languages:</p> <pre><code>class \"ClassName\" {\n    -- members go here\n}\n</code></pre> <p>Example:</p> <pre><code>class \"Animal\" {\n    species = \"Unknown\";\n\n    speak = function(self)\n        print(\"The \" .. self.species .. \" makes a sound\")\n    end;\n}\n</code></pre> <p>Semicolons</p> <p>Semicolons after each member are optional but recommended. They make it easier to add and remove lines without worrying about commas.</p>"},{"location":"guide/classes/#builder-syntax","title":"Builder Syntax","text":"<p>The Builder syntax looks more like traditional Lua code:</p> <pre><code>local animal = class(\"Animal\")\nanimal.species = \"Unknown\"\n\nfunction animal:speak()\n    print(\"The \" .. self.species .. \" makes a sound\")\nend\n\nanimal:register()\n</code></pre> <p>Don't forget <code>register()</code></p> <p>Builder syntax requires calling <code>:register()</code> at the end to finalize the class definition.</p>"},{"location":"guide/classes/#empty-classes","title":"Empty Classes","text":"<p>You can define classes with no members:</p> Block SyntaxBuilder Syntax <pre><code>class \"Empty\" {}\n</code></pre> <pre><code>local empty = class(\"Empty\")\nempty:register()\n</code></pre>"},{"location":"guide/classes/#class-naming","title":"Class Naming","text":"<p>Class names must be valid Lua identifiers:</p> <ul> <li>Start with a letter or underscore</li> <li>Contain only letters, numbers, and underscores</li> <li>Case-sensitive (<code>Player</code> and <code>player</code> are different classes)</li> </ul> <pre><code>-- Valid names\nclass \"Player\" {}\nclass \"MyClass123\" {}\nclass \"_InternalClass\" {}\n\n-- Invalid names (will cause errors)\nclass \"123Class\" {}    -- starts with number\nclass \"my-class\" {}    -- contains hyphen\nclass \"my class\" {}    -- contains space\n</code></pre>"},{"location":"guide/classes/#where-classes-are-stored","title":"Where Classes Are Stored","text":"<p>By default, classes are stored in the global table (<code>_G</code>). After defining a class, you can access it by name:</p> <pre><code>class \"Player\" {}\n\nprint(Player)           -- SimplooObject: Player &lt;class&gt;\nprint(_G[\"Player\"])     -- SimplooObject: Player &lt;class&gt;\nprint(_G.Player)        -- SimplooObject: Player &lt;class&gt;\n</code></pre> <p>You can change where classes are stored using the <code>baseInstanceTable</code> config option. See Configuration.</p>"},{"location":"guide/classes/#builder-syntax-options","title":"Builder Syntax Options","text":"<p>The builder syntax accepts an optional second argument with class options:</p> <pre><code>local player = class(\"Player\", {\n    extends = \"Entity\",\n    implements = \"Damageable\",\n    namespace = \"game\"\n})\nplayer:register()\n\n-- Results in game.Player extending Entity and implementing Damageable\n</code></pre> <p>Available options:</p> Option Description <code>extends</code> Parent class(es) to inherit from <code>implements</code> Interface(s) to implement <code>namespace</code> Namespace for this class"},{"location":"guide/classes/#comparing-syntaxes","title":"Comparing Syntaxes","text":"Feature Block Syntax Builder Syntax Looks like Other OOP languages Traditional Lua Registration Automatic Manual (<code>:register()</code>) Method definition Inline functions Separate function blocks Best for Concise class definitions Complex setup logic"},{"location":"guide/classes/#complete-example","title":"Complete Example","text":"<p>Here's the same class in both syntaxes:</p> Block SyntaxBuilder Syntax <pre><code>dofile(\"simploo.lua\")\n\nclass \"Rectangle\" {\n    width = 0;\n    height = 0;\n\n    __construct = function(self, w, h)\n        self.width = w\n        self.height = h\n    end;\n\n    getArea = function(self)\n        return self.width * self.height\n    end;\n\n    getPerimeter = function(self)\n        return 2 * (self.width + self.height)\n    end;\n}\n\nlocal rect = Rectangle.new(5, 3)\nprint(rect:getArea())       -- 15\nprint(rect:getPerimeter())  -- 16\n</code></pre> <pre><code>dofile(\"simploo.lua\")\n\nlocal rect = class(\"Rectangle\")\nrect.width = 0\nrect.height = 0\n\nfunction rect:__construct(w, h)\n    self.width = w\n    self.height = h\nend\n\nfunction rect:getArea()\n    return self.width * self.height\nend\n\nfunction rect:getPerimeter()\n    return 2 * (self.width + self.height)\nend\n\nrect:register()\n\nlocal r = Rectangle.new(5, 3)\nprint(r:getArea())       -- 15\nprint(r:getPerimeter())  -- 16\n</code></pre>"},{"location":"guide/constructors/","title":"Constructors and Finalizers","text":"<p>SIMPLOO provides special methods for initialization and cleanup of instances.</p>"},{"location":"guide/constructors/#constructor-__construct","title":"Constructor: <code>__construct</code>","text":"<p>The <code>__construct</code> method is called automatically when creating a new instance. Use it to initialize your instance with custom values.</p> Block SyntaxBuilder Syntax <pre><code>class \"Player\" {\n    name = \"\";\n    health = 100;\n    level = 1;\n\n    __construct = function(self, playerName, startLevel)\n        self.name = playerName\n        self.level = startLevel or 1\n        print(self.name .. \" has entered the game!\")\n    end;\n}\n</code></pre> <pre><code>local player = class(\"Player\")\nplayer.name = \"\"\nplayer.health = 100\nplayer.level = 1\n\nfunction player:__construct(playerName, startLevel)\n    self.name = playerName\n    self.level = startLevel or 1\n    print(self.name .. \" has entered the game!\")\nend\n\nplayer:register()\n</code></pre> <pre><code>local p = Player.new(\"Alice\", 5)  -- Alice has entered the game!\nprint(p.name)   -- Alice\nprint(p.level)  -- 5\n</code></pre>"},{"location":"guide/constructors/#constructor-arguments","title":"Constructor Arguments","text":"<p>Arguments passed to <code>.new()</code> are forwarded to <code>__construct</code>:</p> <pre><code>class \"Point\" {\n    x = 0;\n    y = 0;\n\n    __construct = function(self, x, y)\n        self.x = x or 0\n        self.y = y or 0\n    end;\n}\n\nlocal origin = Point.new()         -- x=0, y=0\nlocal point = Point.new(10, 20)    -- x=10, y=20\n</code></pre>"},{"location":"guide/constructors/#finalizer-__finalize","title":"Finalizer: <code>__finalize</code>","text":"<p>The <code>__finalize</code> method is called when an instance is garbage collected. Use it for cleanup tasks like closing files or releasing resources.</p> Block SyntaxBuilder Syntax <pre><code>class \"FileHandler\" {\n    filename = \"\";\n    handle = null;\n\n    __construct = function(self, name)\n        self.filename = name\n        self.handle = io.open(name, \"r\")\n        print(\"Opened: \" .. name)\n    end;\n\n    __finalize = function(self)\n        if self.handle then\n            self.handle:close()\n            print(\"Closed: \" .. self.filename)\n        end\n    end;\n}\n</code></pre> <pre><code>local handler = class(\"FileHandler\")\nhandler.filename = \"\"\nhandler.handle = null\n\nfunction handler:__construct(name)\n    self.filename = name\n    self.handle = io.open(name, \"r\")\n    print(\"Opened: \" .. name)\nend\n\nfunction handler:__finalize()\n    if self.handle then\n        self.handle:close()\n        print(\"Closed: \" .. self.filename)\n    end\nend\n\nhandler:register()\n</code></pre> <p>Garbage Collection Timing</p> <p><code>__finalize</code> runs when Lua's garbage collector cleans up the instance. This timing is not guaranteed - it happens when Lua decides to collect garbage, not immediately when all references are removed.</p>"},{"location":"guide/constructors/#constructor-with-validation","title":"Constructor with Validation","text":"<p>Constructors are a good place to validate input:</p> Block SyntaxBuilder Syntax <pre><code>class \"Circle\" {\n    radius = 0;\n\n    __construct = function(self, r)\n        if type(r) ~= \"number\" or r &lt;= 0 then\n            error(\"Circle radius must be a positive number\")\n        end\n        self.radius = r\n    end;\n\n    getArea = function(self)\n        return math.pi * self.radius * self.radius\n    end;\n}\n</code></pre> <pre><code>local circle = class(\"Circle\")\ncircle.radius = 0\n\nfunction circle:__construct(r)\n    if type(r) ~= \"number\" or r &lt;= 0 then\n        error(\"Circle radius must be a positive number\")\n    end\n    self.radius = r\nend\n\nfunction circle:getArea()\n    return math.pi * self.radius * self.radius\nend\n\ncircle:register()\n</code></pre> <pre><code>local c = Circle.new(5)     -- OK\nlocal bad = Circle.new(-1)  -- Error: Circle radius must be a positive number\n</code></pre>"},{"location":"guide/constructors/#calling-parent-constructors","title":"Calling Parent Constructors","text":"<p>When a child class has its own constructor, you should explicitly call the parent constructor using <code>self.ParentName()</code>:</p> <pre><code>class \"Entity\" {\n    id = 0;\n\n    __construct = function(self, entityId)\n        self.id = entityId\n        print(\"Entity created: \" .. self.id)\n    end;\n}\n\nclass \"Player\" extends \"Entity\" {\n    name = \"\";\n\n    __construct = function(self, playerId, playerName)\n        self.Entity(playerId)  -- Call parent constructor\n        self.name = playerName\n        print(\"Player created: \" .. self.name)\n    end;\n}\n\nlocal p = Player.new(42, \"Alice\")\n-- Entity created: 42\n-- Player created: Alice\n</code></pre> <p>Dev Mode Warning</p> <p>In development mode (when <code>production</code> config is <code>false</code>), SIMPLOO warns if you forget to call a parent constructor. This helps catch common bugs where parent initialization is skipped.</p> <pre><code>class \"BadChild\" extends \"Entity\" {\n    __construct = function(self)\n        -- Forgot to call self.Entity()!\n    end;\n}\n\nlocal b = BadChild.new()\n-- WARNING: class BadChild: parent constructor Entity() was not called\n</code></pre>"},{"location":"guide/constructors/#multiple-inheritance","title":"Multiple Inheritance","text":"<p>When extending multiple parents, call each parent's constructor:</p> <pre><code>class \"Swimmer\" {\n    swimSpeed = 0;\n\n    __construct = function(self, speed)\n        self.swimSpeed = speed\n    end;\n}\n\nclass \"Flyer\" {\n    flySpeed = 0;\n\n    __construct = function(self, speed)\n        self.flySpeed = speed\n    end;\n}\n\nclass \"Duck\" extends \"Swimmer, Flyer\" {\n    __construct = function(self, swimSpeed, flySpeed)\n        self.Swimmer(swimSpeed)\n        self.Flyer(flySpeed)\n    end;\n}\n\nlocal d = Duck.new(5, 10)\nprint(d.swimSpeed)  -- 5\nprint(d.flySpeed)   -- 10\n</code></pre>"},{"location":"guide/constructors/#no-constructor-inheritance","title":"No Constructor Inheritance","text":"<p>If a child class defines its own constructor, the parent constructor is not automatically called. You must call it explicitly. If the child has no constructor, it inherits the parent's:</p> <pre><code>class \"Parent\" {\n    __construct = function(self)\n        print(\"Parent constructor\")\n    end;\n}\n\nclass \"ChildWithConstructor\" extends \"Parent\" {\n    __construct = function(self)\n        -- Parent constructor NOT called unless we do: self.Parent()\n        print(\"Child constructor\")\n    end;\n}\n\nclass \"ChildWithoutConstructor\" extends \"Parent\" {\n    -- No constructor - inherits Parent's constructor\n}\n\nChildWithConstructor.new()     -- Only prints: Child constructor\nChildWithoutConstructor.new()  -- Prints: Parent constructor\n</code></pre>"},{"location":"guide/constructors/#no-constructor-needed","title":"No Constructor Needed","text":"<p>If you don't need custom initialization, you can omit <code>__construct</code>. Instances will use the default values:</p> <pre><code>class \"Simple\" {\n    value = 42;\n}\n\nlocal s = Simple.new()\nprint(s.value)  -- 42\n</code></pre>"},{"location":"guide/constructors/#complete-example","title":"Complete Example","text":"Block SyntaxBuilder Syntax <pre><code>dofile(\"simploo.lua\")\n\nclass \"Connection\" {\n    host = \"\";\n    port = 0;\n    connected = false;\n\n    __construct = function(self, host, port)\n        self.host = host\n        self.port = port\n        self:connect()\n    end;\n\n    __finalize = function(self)\n        self:disconnect()\n    end;\n\n    connect = function(self)\n        print(\"Connecting to \" .. self.host .. \":\" .. self.port)\n        self.connected = true\n    end;\n\n    disconnect = function(self)\n        if self.connected then\n            print(\"Disconnecting from \" .. self.host)\n            self.connected = false\n        end\n    end;\n\n    send = function(self, data)\n        if self.connected then\n            print(\"Sending: \" .. data)\n        else\n            error(\"Not connected!\")\n        end\n    end;\n}\n\nlocal conn = Connection.new(\"localhost\", 8080)\n-- Output: Connecting to localhost:8080\n\nconn:send(\"Hello\")\n-- Output: Sending: Hello\n\nconn = nil\ncollectgarbage()\n-- Output: Disconnecting from localhost\n</code></pre> <pre><code>dofile(\"simploo.lua\")\n\nlocal connection = class(\"Connection\")\nconnection.host = \"\"\nconnection.port = 0\nconnection.connected = false\n\nfunction connection:__construct(host, port)\n    self.host = host\n    self.port = port\n    self:connect()\nend\n\nfunction connection:__finalize()\n    self:disconnect()\nend\n\nfunction connection:connect()\n    print(\"Connecting to \" .. self.host .. \":\" .. self.port)\n    self.connected = true\nend\n\nfunction connection:disconnect()\n    if self.connected then\n        print(\"Disconnecting from \" .. self.host)\n        self.connected = false\n    end\nend\n\nfunction connection:send(data)\n    if self.connected then\n        print(\"Sending: \" .. data)\n    else\n        error(\"Not connected!\")\n    end\nend\n\nconnection:register()\n\nlocal conn = Connection.new(\"localhost\", 8080)\n-- Output: Connecting to localhost:8080\n\nconn:send(\"Hello\")\n-- Output: Sending: Hello\n\nconn = nil\ncollectgarbage()\n-- Output: Disconnecting from localhost\n</code></pre>"},{"location":"guide/inheritance/","title":"Inheritance","text":"<p>Inheritance lets you create new classes based on existing ones, reusing and extending their functionality.</p>"},{"location":"guide/inheritance/#single-inheritance","title":"Single Inheritance","text":"<p>Use <code>extends</code> to inherit from a parent class:</p> Block SyntaxBuilder Syntax <pre><code>class \"Animal\" {\n    name = \"\";\n\n    speak = function(self)\n        print(self.name .. \" makes a sound\")\n    end;\n}\n\nclass \"Dog\" extends \"Animal\" {\n    breed = \"\";\n\n    bark = function(self)\n        print(self.name .. \" barks!\")\n    end;\n}\n</code></pre> <pre><code>local animal = class(\"Animal\")\nanimal.name = \"\"\n\nfunction animal:speak()\n    print(self.name .. \" makes a sound\")\nend\n\nanimal:register()\n\nlocal dog = class(\"Dog\", {extends = \"Animal\"})\ndog.breed = \"\"\n\nfunction dog:bark()\n    print(self.name .. \" barks!\")\nend\n\ndog:register()\n</code></pre> <pre><code>local d = Dog.new()\nd.name = \"Buddy\"\nd.breed = \"Labrador\"\n\nd:speak()  -- Buddy makes a sound (inherited)\nd:bark()   -- Buddy barks! (own method)\n</code></pre>"},{"location":"guide/inheritance/#multiple-inheritance","title":"Multiple Inheritance","text":"<p>Inherit from multiple classes by separating names with commas:</p> Block SyntaxBuilder Syntax <pre><code>class \"Swimmer\" {\n    canSwim = true;\n\n    swim = function(self)\n        print(\"Swimming!\")\n    end;\n}\n\nclass \"Flyer\" {\n    canFly = true;\n\n    fly = function(self)\n        print(\"Flying!\")\n    end;\n}\n\nclass \"Duck\" extends \"Animal, Swimmer, Flyer\" {\n    quack = function(self)\n        print(self.name .. \" quacks\")\n    end;\n}\n</code></pre> <pre><code>local swimmer = class(\"Swimmer\")\nswimmer.canSwim = true\nfunction swimmer:swim()\n    print(\"Swimming!\")\nend\nswimmer:register()\n\nlocal flyer = class(\"Flyer\")\nflyer.canFly = true\nfunction flyer:fly()\n    print(\"Flying!\")\nend\nflyer:register()\n\nlocal duck = class(\"Duck\", {extends = \"Animal, Swimmer, Flyer\"})\nfunction duck:quack()\n    print(self.name .. \" quacks\")\nend\nduck:register()\n</code></pre> <pre><code>local d = Duck.new()\nd.name = \"Donald\"\n\nd:speak()  -- Donald makes a sound (from Animal)\nd:swim()   -- Swimming! (from Swimmer)\nd:fly()    -- Flying! (from Flyer)\nd:quack()  -- Donald quacks (own method)\n\n-- Access inherited properties\nprint(d.canSwim)  -- true\nprint(d.canFly)   -- true\n</code></pre> <p>Polymorphism</p> <p>Parent methods have access to all inherited members. A method defined in <code>Swimmer</code> can access <code>name</code> from <code>Animal</code> when called on a <code>Duck</code> instance, because <code>self</code> refers to the full <code>Duck</code> instance with all its inherited members.</p>"},{"location":"guide/inheritance/#accessing-parent-members","title":"Accessing Parent Members","text":"<p>Access parent instances using <code>self.ParentName</code>:</p> <pre><code>class \"Vehicle\" {\n    speed = 0;\n\n    accelerate = function(self, amount)\n        self.speed = self.speed + amount\n    end;\n}\n\nclass \"Car\" extends \"Vehicle\" {\n    wheels = 4;\n\n    turboBoost = function(self)\n        -- Access parent method\n        self.Vehicle:accelerate(50)\n        print(\"Turbo! Speed: \" .. self.speed)\n    end;\n}\n\nlocal car = Car.new()\ncar:accelerate(20)   -- speed = 20\ncar:turboBoost()     -- Turbo! Speed: 70\n</code></pre>"},{"location":"guide/inheritance/#calling-parent-constructors","title":"Calling Parent Constructors","text":"<p>When a child has a constructor, call the parent constructor explicitly:</p> <pre><code>class \"Entity\" {\n    id = 0;\n\n    __construct = function(self, entityId)\n        self.id = entityId\n        print(\"Entity created: \" .. self.id)\n    end;\n}\n\nclass \"Player\" extends \"Entity\" {\n    name = \"\";\n\n    __construct = function(self, playerId, playerName)\n        -- Call parent constructor\n        self.Entity(playerId)\n\n        self.name = playerName\n        print(\"Player created: \" .. self.name)\n    end;\n}\n\nlocal p = Player.new(42, \"Alice\")\n-- Entity created: 42\n-- Player created: Alice\n</code></pre>"},{"location":"guide/inheritance/#method-overriding","title":"Method Overriding","text":"<p>Child classes can override parent methods:</p> <pre><code>class \"Shape\" {\n    describe = function(self)\n        print(\"I am a shape\")\n    end;\n}\n\nclass \"Circle\" extends \"Shape\" {\n    radius = 0;\n\n    describe = function(self)\n        print(\"I am a circle with radius \" .. self.radius)\n    end;\n}\n\nlocal s = Shape.new()\ns:describe()  -- I am a shape\n\nlocal c = Circle.new()\nc.radius = 5\nc:describe()  -- I am a circle with radius 5\n</code></pre>"},{"location":"guide/inheritance/#calling-overridden-parent-method","title":"Calling Overridden Parent Method","text":"<p>Use <code>self.ParentName:method()</code> to call the parent's version:</p> <pre><code>class \"Animal\" {\n    describe = function(self)\n        return \"an animal\"\n    end;\n}\n\nclass \"Cat\" extends \"Animal\" {\n    describe = function(self)\n        return self.Animal:describe() .. \" called cat\"\n    end;\n}\n\nlocal c = Cat.new()\nprint(c:describe())  -- an animal called cat\n</code></pre> <p>Polymorphism</p> <p>SIMPLOO fully supports polymorphism - when a parent method calls <code>self:method()</code>, it uses the child's override if one exists. See the Polymorphism guide for details and design pattern examples.</p>"},{"location":"guide/inheritance/#checking-inheritance","title":"Checking Inheritance","text":"<p>Use <code>instance_of</code> to check class relationships:</p> <pre><code>class \"A\" {}\nclass \"B\" extends \"A\" {}\nclass \"C\" extends \"B\" {}\n\nlocal c = C.new()\n\nprint(c:instance_of(C))  -- true\nprint(c:instance_of(B))  -- true\nprint(c:instance_of(A))  -- true\n\nlocal a = A.new()\nprint(a:instance_of(C))  -- false\n</code></pre>"},{"location":"guide/inheritance/#ambiguous-members","title":"Ambiguous Members","text":"<p>When multiple parents have the same member name, accessing it causes an error:</p> <pre><code>class \"Left\" {\n    value = \"left\";\n}\n\nclass \"Right\" {\n    value = \"right\";\n}\n\nclass \"Both\" extends \"Left, Right\" {}\n\nlocal b = Both.new()\nprint(b.value)  -- Error: call to member value is ambiguous\n</code></pre> <p>Resolve by accessing through the specific parent:</p> <pre><code>print(b.Left.value)   -- left\nprint(b.Right.value)  -- right\n</code></pre> <p>Or override in the child:</p> <pre><code>class \"Both\" extends \"Left, Right\" {\n    value = \"both\";  -- Overrides both parents\n}\n\nlocal b = Both.new()\nprint(b.value)  -- both\n</code></pre> <p>Parents with Same Short Name</p> <p>When extending two parents from different namespaces that have the same class name (e.g., <code>ns1.Util</code> and <code>ns2.Util</code>), the short name <code>Util</code> becomes <code>nil</code> (ambiguous). Use <code>using ... as</code> to give them unique aliases:</p> <pre><code>namespace \"ns1\"\nclass \"Util\" { getValue = function(self) return 1 end; }\n\nnamespace \"ns2\"\nclass \"Util\" { getValue = function(self) return 2 end; }\n\nnamespace \"\"\nusing \"ns1.Util\" as \"Util1\"\nusing \"ns2.Util\" as \"Util2\"\n\nclass \"MyClass\" extends \"Util1, Util2\" {}\n\nlocal m = MyClass.new()\nm.Util1:getValue()  -- 1\nm.Util2:getValue()  -- 2\nm.Util               -- nil (ambiguous)\n</code></pre> <p>Alternatively, you can access parents via their full name using bracket notation:</p> <pre><code>class \"MyClass\" extends \"ns1.Util, ns2.Util\" {}\n\nlocal m = MyClass.new()\nm[\"ns1.Util\"]:getValue()  -- 1\nm[\"ns2.Util\"]:getValue()  -- 2\n</code></pre>"},{"location":"guide/inheritance/#deep-inheritance-chains","title":"Deep Inheritance Chains","text":"<p>Inheritance can go multiple levels deep. Use varargs (<code>...</code>) to pass arguments up the chain cleanly:</p> <pre><code>class \"Level1\" {\n    value1 = 0;\n\n    __construct = function(self, v, ...)\n        self.value1 = v\n    end;\n}\n\nclass \"Level2\" extends \"Level1\" {\n    value2 = 0;\n\n    __construct = function(self, v, ...)\n        self.Level1(...)  -- Pass remaining args to parent\n        self.value2 = v\n    end;\n}\n\nclass \"Level3\" extends \"Level2\" {\n    value3 = 0;\n\n    __construct = function(self, v, ...)\n        self.Level2(...)  -- Pass remaining args to parent\n        self.value3 = v\n    end;\n}\n\n-- Arguments are consumed from right to left: v3, v2, v1\nlocal obj = Level3.new(3, 2, 1)\nprint(obj.value1)  -- 1\nprint(obj.value2)  -- 2\nprint(obj.value3)  -- 3\n</code></pre>"},{"location":"guide/instances/","title":"Instances","text":"<p>Instances are objects created from a class definition. Each instance has its own copy of the class members.</p>"},{"location":"guide/instances/#creating-instances","title":"Creating Instances","text":"<p>There are three ways to create an instance:</p> <pre><code>class \"Player\" {\n    name = \"Unknown\";\n}\n\n-- All three are equivalent:\nlocal p1 = Player.new()\nlocal p2 = Player:new()\nlocal p3 = Player()\n</code></pre> <p>All three methods accept constructor arguments:</p> <pre><code>class \"Player\" {\n    name = \"\";\n\n    __construct = function(self, n)\n        self.name = n\n    end;\n}\n\nlocal p1 = Player.new(\"Alice\")\nlocal p2 = Player:new(\"Bob\")\nlocal p3 = Player(\"Charlie\")\n</code></pre>"},{"location":"guide/instances/#class-vs-instance","title":"Class vs Instance","text":"<p>A class is the template. An instance is a copy of that template with its own data.</p> <pre><code>class \"Counter\" {\n    value = 0;\n}\n\n-- Counter is the class\nprint(Counter)  -- SimplooObject: Counter &lt;class&gt;\n\n-- These are instances\nlocal a = Counter.new()\nlocal b = Counter.new()\n\nprint(a)  -- SimplooObject: Counter &lt;instance&gt;\nprint(b)  -- SimplooObject: Counter &lt;instance&gt;\n\n-- Each instance has its own data\na.value = 10\nprint(a.value)  -- 10\nprint(b.value)  -- 0 (unchanged)\n</code></pre>"},{"location":"guide/instances/#class-reference","title":"Class Reference","text":"<p>Every instance can access its class via <code>get_class()</code>:</p> <pre><code>local player = Player.new()\n\nprint(player:get_class() == Player)  -- true\nprint(player:get_name())             -- Player\n</code></pre>"},{"location":"guide/instances/#instance-identity","title":"Instance Identity","text":"<p>Each call to <code>.new()</code> creates a separate instance:</p> <pre><code>local a = Player.new()\nlocal b = Player.new()\nlocal c = a  -- c references the same instance as a\n\nprint(a == b)  -- false (different instances)\nprint(a == c)  -- true (same instance)\n</code></pre>"},{"location":"guide/instances/#built-in-instance-methods","title":"Built-in Instance Methods","text":"<p>Every instance has these methods available:</p>"},{"location":"guide/instances/#get_name","title":"<code>get_name()</code>","text":"<p>Returns the class name as a string:</p> <pre><code>local player = Player.new()\nprint(player:get_name())  -- Player\n</code></pre>"},{"location":"guide/instances/#get_class","title":"<code>get_class()</code>","text":"<p>Returns the class:</p> <pre><code>local player = Player.new()\nprint(player:get_class() == Player)  -- true\n</code></pre>"},{"location":"guide/instances/#instance_ofother","title":"<code>instance_of(other)</code>","text":"<p>Checks if the instance is derived from another class (useful with inheritance):</p> <pre><code>class \"Animal\" {}\nclass \"Dog\" extends \"Animal\" {}\n\nlocal dog = Dog.new()\nprint(dog:instance_of(Animal))  -- true\nprint(dog:instance_of(Dog))     -- true\n</code></pre> <p>See Instance Methods Reference for more details.</p>"},{"location":"guide/instances/#passing-instances-around","title":"Passing Instances Around","text":"<p>Instances can be passed to functions, stored in tables, and used like any Lua value:</p> <pre><code>class \"Player\" {\n    name = \"\";\n    health = 100;\n\n    __construct = function(self, n)\n        self.name = n\n    end;\n}\n\n-- Store in a table\nlocal players = {}\ntable.insert(players, Player.new(\"Alice\"))\ntable.insert(players, Player.new(\"Bob\"))\n\n-- Pass to a function\nlocal function damage(player, amount)\n    player.health = player.health - amount\nend\n\ndamage(players[1], 25)\nprint(players[1].health)  -- 75\n</code></pre>"},{"location":"guide/instances/#complete-example","title":"Complete Example","text":"Block SyntaxBuilder Syntax <pre><code>dofile(\"simploo.lua\")\n\nclass \"Enemy\" {\n    name = \"Unknown\";\n    health = 50;\n    damage = 10;\n\n    __construct = function(self, name, hp, dmg)\n        self.name = name\n        self.health = hp or 50\n        self.damage = dmg or 10\n    end;\n\n    attack = function(self, target)\n        print(self.name .. \" attacks \" .. target.name .. \" for \" .. self.damage .. \" damage!\")\n        target.health = target.health - self.damage\n    end;\n\n    isAlive = function(self)\n        return self.health &gt; 0\n    end;\n}\n\n-- Create multiple instances\nlocal goblin = Enemy.new(\"Goblin\", 30, 5)\nlocal orc = Enemy.new(\"Orc\", 100, 20)\nlocal dragon = Enemy(\"Dragon\", 500, 50)\n\n-- Each has its own state\nprint(goblin.health)  -- 30\nprint(orc.health)     -- 100\nprint(dragon.health)  -- 500\n\n-- Instances interact\ndragon:attack(goblin)  -- Dragon attacks Goblin for 50 damage!\nprint(goblin:isAlive())  -- false\n</code></pre> <pre><code>dofile(\"simploo.lua\")\n\nlocal enemy = class(\"Enemy\")\nenemy.name = \"Unknown\"\nenemy.health = 50\nenemy.damage = 10\n\nfunction enemy:__construct(name, hp, dmg)\n    self.name = name\n    self.health = hp or 50\n    self.damage = dmg or 10\nend\n\nfunction enemy:attack(target)\n    print(self.name .. \" attacks \" .. target.name .. \" for \" .. self.damage .. \" damage!\")\n    target.health = target.health - self.damage\nend\n\nfunction enemy:isAlive()\n    return self.health &gt; 0\nend\n\nenemy:register()\n\n-- Create multiple instances\nlocal goblin = Enemy.new(\"Goblin\", 30, 5)\nlocal orc = Enemy.new(\"Orc\", 100, 20)\nlocal dragon = Enemy(\"Dragon\", 500, 50)\n\n-- Each has its own state\nprint(goblin.health)  -- 30\nprint(orc.health)     -- 100\nprint(dragon.health)  -- 500\n\n-- Instances interact\ndragon:attack(goblin)  -- Dragon attacks Goblin for 50 damage!\nprint(goblin:isAlive())  -- false\n</code></pre>"},{"location":"guide/interfaces/","title":"Interfaces","text":"<p>Interfaces define a contract that classes must fulfill. They specify method signatures that implementing classes are required to have.</p>"},{"location":"guide/interfaces/#defining-an-interface","title":"Defining an Interface","text":"Block SyntaxBuilder Syntax <pre><code>interface \"Damageable\" {\n    takeDamage = function(self, amount) end;\n    getHealth = function(self) end;\n}\n</code></pre> <pre><code>local damageable = interface(\"Damageable\")\ndamageable.takeDamage = function(self, amount) end\ndamageable.getHealth = function(self) end\ndamageable:register()\n</code></pre> <p>Interface methods are just signatures - the function bodies are empty. They document:</p> <ul> <li>The method name</li> <li>Expected arguments</li> </ul> <p>Interface Restrictions</p> <p>Interfaces can only contain:</p> <ul> <li>Required methods - must be implemented by classes</li> <li>Default methods - optional, with a default implementation</li> </ul> <p>Variables, static methods, and private/protected members are not allowed in interfaces.</p>"},{"location":"guide/interfaces/#implementing-an-interface","title":"Implementing an Interface","text":"<p>Use <code>implements</code> to declare that a class fulfills an interface contract:</p> Block SyntaxBuilder Syntax <pre><code>class \"Player\" implements \"Damageable\" {\n    health = 100;\n\n    takeDamage = function(self, amount)\n        self.health = self.health - amount\n    end;\n\n    getHealth = function(self)\n        return self.health\n    end;\n}\n</code></pre> <pre><code>local player = class(\"Player\", {implements = \"Damageable\"})\nplayer.health = 100\n\nfunction player:takeDamage(amount)\n    self.health = self.health - amount\nend\n\nfunction player:getHealth()\n    return self.health\nend\n\nplayer:register()\n</code></pre> <p>If you forget to implement a required method, you get an error at class definition time:</p> <pre><code>class \"Wall\" implements \"Damageable\" {\n    -- missing takeDamage and getHealth\n}\n-- Error: class Wall: missing method 'takeDamage' required by interface Damageable\n</code></pre>"},{"location":"guide/interfaces/#default-methods","title":"Default Methods","text":"<p>Use <code>default</code> for optional methods that have a default implementation:</p> Block Syntax <pre><code>interface \"Damageable\" {\n    takeDamage = function(self, amount) end;  -- required\n    getHealth = function(self) end;           -- required\n\n    default {\n        onDeath = function(self)              -- optional\n            print(self:get_name() .. \" died\")\n        end;\n    };\n}\n\nclass \"Player\" implements \"Damageable\" {\n    health = 100;\n\n    takeDamage = function(self, amount)\n        self.health = self.health - amount\n        if self.health &lt;= 0 then\n            self:onDeath()  -- uses default implementation\n        end\n    end;\n\n    getHealth = function(self)\n        return self.health\n    end;\n\n    -- onDeath not implemented, uses default from interface\n}\n\nclass \"Boss\" implements \"Damageable\" {\n    health = 1000;\n\n    takeDamage = function(self, amount)\n        self.health = self.health - amount\n    end;\n\n    getHealth = function(self)\n        return self.health\n    end;\n\n    onDeath = function(self)  -- override default\n        print(\"BOSS DEFEATED!\")\n        self:dropLoot()\n        self.Damageable:onDeath()  -- call default implementation\n    end;\n}\n</code></pre> <p>You can call the default implementation from an override using <code>self.InterfaceName:method()</code>, similar to calling parent methods in class inheritance.</p> Builder Syntax <pre><code>local damageable = interface(\"Damageable\")\ndamageable.takeDamage = function(self, amount) end  -- required\ndamageable.getHealth = function(self) end           -- required\ndamageable.default.onDeath = function(self)         -- optional\n    print(self:get_name() .. \" died\")\nend\ndamageable:register()\n\nlocal player = class(\"Player\", {implements = \"Damageable\"})\nplayer.health = 100\n\nfunction player:takeDamage(amount)\n    self.health = self.health - amount\n    if self.health &lt;= 0 then\n        self:onDeath()  -- uses default implementation\n    end\nend\n\nfunction player:getHealth()\n    return self.health\nend\n\n-- onDeath not implemented, uses default from interface\nplayer:register()\n\nlocal boss = class(\"Boss\", {implements = \"Damageable\"})\nboss.health = 1000\n\nfunction boss:takeDamage(amount)\n    self.health = self.health - amount\nend\n\nfunction boss:getHealth()\n    return self.health\nend\n\nfunction boss:onDeath()  -- override default\n    print(\"BOSS DEFEATED!\")\n    self:dropLoot()\nend\n\nboss:register()\n</code></pre>"},{"location":"guide/interfaces/#multiple-interfaces","title":"Multiple Interfaces","text":"<p>A class can implement multiple interfaces:</p> Block SyntaxBuilder Syntax <pre><code>interface \"Damageable\" {\n    takeDamage = function(self, amount) end;\n}\n\ninterface \"Serializable\" {\n    serialize = function(self) end;\n    deserialize = function(self, data) end;\n}\n\nclass \"Player\" implements \"Damageable, Serializable\" {\n    takeDamage = function(self, amount) ... end;\n    serialize = function(self) ... end;\n    deserialize = function(self, data) ... end;\n}\n</code></pre> <pre><code>local damageable = interface(\"Damageable\")\ndamageable.takeDamage = function(self, amount) end\ndamageable:register()\n\nlocal serializable = interface(\"Serializable\")\nserializable.serialize = function(self) end\nserializable.deserialize = function(self, data) end\nserializable:register()\n\nlocal player = class(\"Player\", {implements = \"Damageable, Serializable\"})\nfunction player:takeDamage(amount) ... end\nfunction player:serialize() ... end\nfunction player:deserialize(data) ... end\nplayer:register()\n</code></pre>"},{"location":"guide/interfaces/#interface-inheritance","title":"Interface Inheritance","text":"<p>Interfaces can extend other interfaces:</p> Block SyntaxBuilder Syntax <pre><code>interface \"Damageable\" {\n    takeDamage = function(self, amount) end;\n    getHealth = function(self) end;\n}\n\ninterface \"Killable\" extends \"Damageable\" {\n    onDeath = function(self) end;\n}\n</code></pre> <pre><code>local damageable = interface(\"Damageable\")\ndamageable.takeDamage = function(self, amount) end\ndamageable.getHealth = function(self) end\ndamageable:register()\n\nlocal killable = interface(\"Killable\", {extends = \"Damageable\"})\nkillable.onDeath = function(self) end\nkillable:register()\n</code></pre> <p>A class implementing <code>Killable</code> must implement all methods from both <code>Killable</code> and <code>Damageable</code>:</p> Block SyntaxBuilder Syntax <pre><code>class \"Enemy\" implements \"Killable\" {\n    takeDamage = function(self, amount) ... end;  -- from Damageable\n    getHealth = function(self) ... end;           -- from Damageable\n    onDeath = function(self) ... end;             -- from Killable\n}\n</code></pre> <pre><code>local enemy = class(\"Enemy\", {implements = \"Killable\"})\nfunction enemy:takeDamage(amount) ... end  -- from Damageable\nfunction enemy:getHealth() ... end         -- from Damageable\nfunction enemy:onDeath() ... end           -- from Killable\nenemy:register()\n</code></pre>"},{"location":"guide/interfaces/#combining-extends-and-implements","title":"Combining Extends and Implements","text":"<p>Classes can extend other classes AND implement interfaces:</p> Block SyntaxBuilder Syntax <pre><code>class \"Entity\" {\n    x = 0;\n    y = 0;\n}\n\ninterface \"Damageable\" {\n    takeDamage = function(self, amount) end;\n}\n\nclass \"Player\" extends \"Entity\" implements \"Damageable\" {\n    health = 100;\n\n    takeDamage = function(self, amount)\n        self.health = self.health - amount\n    end;\n}\n</code></pre> <pre><code>local entity = class(\"Entity\")\nentity.x = 0\nentity.y = 0\nentity:register()\n\nlocal damageable = interface(\"Damageable\")\ndamageable.takeDamage = function(self, amount) end\ndamageable:register()\n\nlocal player = class(\"Player\", {extends = \"Entity\", implements = \"Damageable\"})\nplayer.health = 100\n\nfunction player:takeDamage(amount)\n    self.health = self.health - amount\nend\n\nplayer:register()\n</code></pre>"},{"location":"guide/interfaces/#checking-interface-implementation","title":"Checking Interface Implementation","text":"<p>Use <code>instance_of</code> to check if an instance implements an interface:</p> <pre><code>local player = Player()\nlocal wall = Wall()\n\nplayer:instance_of(Damageable)  -- true\nwall:instance_of(Damageable)    -- false\n\n-- Also works for inherited interfaces\nplayer:instance_of(Killable)    -- true (if Player implements Killable)\nplayer:instance_of(Damageable)  -- true (inherited from Killable)\n</code></pre>"},{"location":"guide/interfaces/#common-pattern-safe-interface-calls","title":"Common Pattern: Safe Interface Calls","text":"<p>Check before calling interface methods on unknown objects:</p> <pre><code>function damageAllInArea(objects, amount)\n    for _, obj in pairs(objects) do\n        if obj:instance_of(Damageable) then\n            obj:takeDamage(amount)\n        end\n    end\nend\n</code></pre>"},{"location":"guide/interfaces/#interfaces-cannot-be-instantiated","title":"Interfaces Cannot Be Instantiated","text":"<pre><code>interface \"Damageable\" {\n    takeDamage = function(self, amount) end;\n}\n\nDamageable.new()  -- Error: cannot instantiate interface Damageable\n</code></pre>"},{"location":"guide/interfaces/#namespaces","title":"Namespaces","text":"<p>Interfaces work with namespaces like classes:</p> Block SyntaxBuilder Syntax <pre><code>namespace \"game.combat\"\n\ninterface \"Damageable\" {\n    takeDamage = function(self, amount) end;\n}\n\nclass \"Player\" implements \"Damageable\" {\n    takeDamage = function(self, amount) ... end;\n}\n\n-- Access via namespace\nlocal p = game.combat.Player()\np:instance_of(game.combat.Damageable)  -- true\n</code></pre> <pre><code>namespace \"game.combat\"\n\nlocal damageable = interface(\"Damageable\")\ndamageable.takeDamage = function(self, amount) end\ndamageable:register()\n\nlocal player = class(\"Player\", {implements = \"Damageable\"})\nfunction player:takeDamage(amount) ... end\nplayer:register()\n\n-- Access via namespace\nlocal p = game.combat.Player()\np:instance_of(game.combat.Damageable)  -- true\n</code></pre>"},{"location":"guide/interfaces/#strict-interface-checking","title":"Strict Interface Checking","text":"<p>By default, SIMPLOO only checks that implementing methods exist and have the correct type. Enable <code>strictInterfaces</code> for additional validation:</p> <pre><code>simploo.config[\"strictInterfaces\"] = true\n</code></pre> <p>With strict checking enabled, SIMPLOO also verifies:</p> <ul> <li>Argument count matches the interface signature</li> <li>Argument names match the interface signature  </li> <li>Varargs (<code>...</code>) are present if the interface requires them</li> </ul> <pre><code>interface \"Formatter\" {\n    format = function(self, template, ...) end;\n}\n\n-- This fails with strictInterfaces = true:\nclass \"BadFormatter\" implements \"Formatter\" {\n    format = function(self, str)  -- wrong arg name, missing varargs\n        return str\n    end;\n}\n-- Error: class BadFormatter: method 'format' argument 2 is named 'str' but interface Formatter expects 'template'\n</code></pre> <p>Note</p> <p>Strict interface checking requires Lua 5.2+. On Lua 5.1, this setting has no effect.</p>"},{"location":"guide/members/","title":"Members","text":"<p>Classes contain two types of members: variables (data) and methods (functions).</p>"},{"location":"guide/members/#variables","title":"Variables","text":"<p>Variables store data for each instance. Define them with a name and default value:</p> Block SyntaxBuilder Syntax <pre><code>class \"Player\" {\n    name = \"Unknown\";\n    health = 100;\n    score = 0;\n    isAlive = true;\n    inventory = {};\n}\n</code></pre> <pre><code>local player = class(\"Player\")\nplayer.name = \"Unknown\"\nplayer.health = 100\nplayer.score = 0\nplayer.isAlive = true\nplayer.inventory = {}\nplayer:register()\n</code></pre>"},{"location":"guide/members/#methods","title":"Methods","text":"<p>Methods are functions that operate on instances. The first parameter is always <code>self</code>, which refers to the instance:</p> Block SyntaxBuilder Syntax <pre><code>class \"Player\" {\n    health = 100;\n\n    takeDamage = function(self, amount)\n        self.health = self.health - amount\n    end;\n\n    heal = function(self, amount)\n        self.health = self.health + amount\n    end;\n\n    getStatus = function(self)\n        return \"Health: \" .. self.health\n    end;\n}\n</code></pre> <pre><code>local player = class(\"Player\")\nplayer.health = 100\n\nfunction player:takeDamage(amount)\n    self.health = self.health - amount\nend\n\nfunction player:heal(amount)\n    self.health = self.health + amount\nend\n\nfunction player:getStatus()\n    return \"Health: \" .. self.health\nend\n\nplayer:register()\n</code></pre>"},{"location":"guide/members/#accessing-members","title":"Accessing Members","text":"<p>Use the dot <code>.</code> operator to access variables and the colon <code>:</code> operator to call methods:</p> <pre><code>local player = Player.new()\n\n-- Access variables with dot\nprint(player.health)    -- 100\nplayer.health = 80\n\n-- Call methods with colon\nplayer:takeDamage(20)\nprint(player:getStatus())  -- Health: 60\n</code></pre> <p>Dot vs Colon</p> <ul> <li>Use <code>.</code> for variables: <code>instance.variable</code></li> <li>Use <code>:</code> for methods: <code>instance:method()</code></li> </ul> <p>The colon automatically passes the instance as the first argument (<code>self</code>).</p>"},{"location":"guide/members/#modifying-members","title":"Modifying Members","text":"<p>You can change member values on any instance:</p> <pre><code>local player = Player.new()\nplayer.health = 200           -- Change variable\nplayer:takeDamage(50)         -- Call method that modifies\nprint(player.health)          -- 150\n</code></pre>"},{"location":"guide/members/#constant-members","title":"Constant Members","text":"<p>Use the <code>const</code> modifier to prevent a member from being changed:</p> Block SyntaxBuilder Syntax <pre><code>class \"Config\" {\n    const {\n        MAX_HEALTH = 100;\n    };\n\n    health = 100;\n}\n</code></pre> <pre><code>local config = class(\"Config\")\nconfig.const.MAX_HEALTH = 100\nconfig.health = 100\nconfig:register()\n</code></pre> <pre><code>local c = Config.new()\nc.health = 50        -- OK\nc.MAX_HEALTH = 200   -- Error: can not modify const variable MAX_HEALTH\n</code></pre>"},{"location":"guide/members/#instance-independence","title":"Instance Independence","text":"<p>Each instance has its own copy of all members:</p> <pre><code>class \"Counter\" {\n    value = 0;\n\n    increment = function(self)\n        self.value = self.value + 1\n    end;\n}\n\nlocal a = Counter.new()\nlocal b = Counter.new()\n\na:increment()\na:increment()\na:increment()\n\nprint(a.value)  -- 3\nprint(b.value)  -- 0 (unchanged)\n</code></pre>"},{"location":"guide/members/#table-members","title":"Table Members","text":"<p>When using tables as default values, each instance gets its own copy:</p> <pre><code>class \"Inventory\" {\n    items = {};\n\n    addItem = function(self, item)\n        table.insert(self.items, item)\n    end;\n}\n\nlocal inv1 = Inventory.new()\nlocal inv2 = Inventory.new()\n\ninv1:addItem(\"Sword\")\ninv1:addItem(\"Shield\")\n\nprint(#inv1.items)  -- 2\nprint(#inv2.items)  -- 0 (separate table)\n</code></pre>"},{"location":"guide/members/#methods-calling-methods","title":"Methods Calling Methods","text":"<p>Methods can call other methods on the same instance using <code>self</code>:</p> Block SyntaxBuilder Syntax <pre><code>class \"Calculator\" {\n    value = 0;\n\n    add = function(self, n)\n        self.value = self.value + n\n    end;\n\n    double = function(self)\n        self:add(self.value)\n    end;\n\n    reset = function(self)\n        self.value = 0\n    end;\n\n    calculate = function(self)\n        self:add(5)\n        self:double()\n        return self.value\n    end;\n}\n</code></pre> <pre><code>local calc = class(\"Calculator\")\ncalc.value = 0\n\nfunction calc:add(n)\n    self.value = self.value + n\nend\n\nfunction calc:double()\n    self:add(self.value)\nend\n\nfunction calc:reset()\n    self.value = 0\nend\n\nfunction calc:calculate()\n    self:add(5)\n    self:double()\n    return self.value\nend\n\ncalc:register()\n</code></pre> <pre><code>local c = Calculator.new()\nprint(c:calculate())  -- 10\n</code></pre>"},{"location":"guide/members/#complete-example","title":"Complete Example","text":"Block SyntaxBuilder Syntax <pre><code>dofile(\"simploo.lua\")\n\nclass \"BankAccount\" {\n    owner = \"Anonymous\";\n    balance = 0;\n\n    deposit = function(self, amount)\n        if amount &gt; 0 then\n            self.balance = self.balance + amount\n            return true\n        end\n        return false\n    end;\n\n    withdraw = function(self, amount)\n        if amount &gt; 0 and amount &lt;= self.balance then\n            self.balance = self.balance - amount\n            return true\n        end\n        return false\n    end;\n\n    getStatement = function(self)\n        return self.owner .. \"'s balance: $\" .. self.balance\n    end;\n}\n\nlocal account = BankAccount.new()\naccount.owner = \"Alice\"\naccount:deposit(100)\naccount:withdraw(30)\nprint(account:getStatement())  -- Alice's balance: $70\n</code></pre> <pre><code>dofile(\"simploo.lua\")\n\nlocal account = class(\"BankAccount\")\naccount.owner = \"Anonymous\"\naccount.balance = 0\n\nfunction account:deposit(amount)\n    if amount &gt; 0 then\n        self.balance = self.balance + amount\n        return true\n    end\n    return false\nend\n\nfunction account:withdraw(amount)\n    if amount &gt; 0 and amount &lt;= self.balance then\n        self.balance = self.balance - amount\n        return true\n    end\n    return false\nend\n\nfunction account:getStatement()\n    return self.owner .. \"'s balance: $\" .. self.balance\nend\n\naccount:register()\n\nlocal acc = BankAccount.new()\nacc.owner = \"Alice\"\nacc:deposit(100)\nacc:withdraw(30)\nprint(acc:getStatement())  -- Alice's balance: $70\n</code></pre> <p>About Access Control</p> <p>All members shown here are implicitly <code>public</code>, meaning they can be accessed from anywhere. To restrict access, see Access Control.</p>"},{"location":"guide/namespaces/","title":"Namespaces","text":"<p>Namespaces help organize classes into logical groups and prevent naming conflicts.</p> <p>Performance Note</p> <p>Classes in namespaces use function environments (fenv) to enable short name references like <code>Player</code> instead of <code>game.Player</code>. This adds a small runtime overhead (~10%) when accessing global variables like <code>math</code>, <code>string</code>, etc. The fenv is set once during class registration, not per instance. Classes without a namespace don't have this overhead.</p>"},{"location":"guide/namespaces/#declaring-a-namespace","title":"Declaring a Namespace","text":"<p>Use <code>namespace</code> before defining classes:</p> Block SyntaxBuilder Syntax <pre><code>namespace \"game.entities\"\n\nclass \"Player\" {\n    name = \"\";\n}\n\nclass \"Enemy\" {\n    health = 100;\n}\n</code></pre> <pre><code>namespace \"game.entities\"\n\nlocal player = class(\"Player\")\nplayer.name = \"\"\nplayer:register()\n\nlocal enemy = class(\"Enemy\")\nenemy.health = 100\nenemy:register()\n</code></pre> <p>Classes are stored in nested tables matching the namespace:</p> <pre><code>-- Access via full path\nlocal p = game.entities.Player.new()\nlocal e = game.entities.Enemy.new()\n\n-- Or via _G\nlocal p = _G[\"game\"][\"entities\"][\"Player\"].new()\n</code></pre>"},{"location":"guide/namespaces/#nested-namespaces","title":"Nested Namespaces","text":"<p>Use dots to create deeper hierarchies:</p> <pre><code>namespace \"com.mycompany.myapp.models\"\n\nclass \"User\" {}\nclass \"Product\" {}\n\n-- Access:\nlocal user = com.mycompany.myapp.models.User.new()\n</code></pre>"},{"location":"guide/namespaces/#switching-namespaces","title":"Switching Namespaces","text":"<p>Each <code>namespace</code> call changes the current namespace for subsequent classes:</p> <pre><code>namespace \"audio\"\n\nclass \"Sound\" {}\nclass \"Music\" {}\n\nnamespace \"graphics\"\n\nclass \"Sprite\" {}\nclass \"Texture\" {}\n\n-- Results in:\n-- audio.Sound, audio.Music\n-- graphics.Sprite, graphics.Texture\n</code></pre>"},{"location":"guide/namespaces/#empty-namespace","title":"Empty Namespace","text":"<p>By default, SIMPLOO starts with an empty namespace, meaning classes are defined in <code>_G</code> directly.</p> <p>Use an empty string to return to the global namespace after using a named namespace:</p> <pre><code>class \"Global1\" {}  -- Global1 (in _G directly, default)\n\nnamespace \"utils\"\nclass \"Helper\" {}  -- utils.Helper\n\nnamespace \"\"\nclass \"Global2\" {}  -- Global2 (back in _G directly)\n</code></pre>"},{"location":"guide/namespaces/#using-classes-from-other-namespaces","title":"Using Classes from Other Namespaces","text":"<p>The <code>using</code> keyword imports classes so you can reference them without the full path:</p> Block SyntaxBuilder Syntax <pre><code>namespace \"game.weapons\"\n\nclass \"Sword\" {\n    damage = 10;\n}\n\nnamespace \"game.entities\"\n\nusing \"game.weapons.Sword\"\n\nclass \"Knight\" {\n    attack = function(self)\n        -- Can use Sword directly instead of game.weapons.Sword\n        local weapon = Sword.new()\n        return weapon.damage\n    end;\n}\n</code></pre> <pre><code>namespace \"game.weapons\"\n\nlocal sword = class(\"Sword\")\nsword.damage = 10\nsword:register()\n\nnamespace \"game.entities\"\n\nusing \"game.weapons.Sword\"\n\nlocal knight = class(\"Knight\")\nfunction knight:attack()\n    local weapon = Sword.new()\n    return weapon.damage\nend\nknight:register()\n</code></pre>"},{"location":"guide/namespaces/#wildcard-imports","title":"Wildcard Imports","text":"<p>Import all classes from a namespace with <code>*</code>:</p> Block SyntaxBuilder Syntax <pre><code>namespace \"math.shapes\"\n\nclass \"Circle\" {}\nclass \"Rectangle\" {}\nclass \"Triangle\" {}\n\nnamespace \"rendering\"\n\nusing \"math.shapes.*\"\n\nclass \"Renderer\" {\n    render = function(self)\n        -- All shapes available directly\n        local c = Circle.new()\n        local r = Rectangle.new()\n        local t = Triangle.new()\n    end;\n}\n</code></pre> <pre><code>namespace \"math.shapes\"\n\nclass(\"Circle\"):register()\nclass(\"Rectangle\"):register()\nclass(\"Triangle\"):register()\n\nnamespace \"rendering\"\n\nusing \"math.shapes.*\"\n\nlocal renderer = class(\"Renderer\")\nfunction renderer:render()\n    local c = Circle.new()\n    local r = Rectangle.new()\n    local t = Triangle.new()\nend\nrenderer:register()\n</code></pre>"},{"location":"guide/namespaces/#aliasing-with-as","title":"Aliasing with <code>as</code>","text":"<p>Rename imported classes to avoid conflicts:</p> Block SyntaxBuilder Syntax <pre><code>namespace \"graphics\"\nclass \"Image\" {}\n\nnamespace \"data\"\nclass \"Image\" {}  -- Same name, different namespace\n\nnamespace \"app\"\n\nusing \"graphics.Image\" as \"GraphicsImage\"\nusing \"data.Image\" as \"DataImage\"\n\nclass \"Processor\" {\n    process = function(self)\n        local gImg = GraphicsImage.new()\n        local dImg = DataImage.new()\n    end;\n}\n</code></pre> <pre><code>namespace \"graphics\"\nclass(\"Image\"):register()\n\nnamespace \"data\"\nclass(\"Image\"):register()\n\nnamespace \"app\"\n\nusing \"graphics.Image\" as \"GraphicsImage\"\nusing \"data.Image\" as \"DataImage\"\n\nlocal processor = class(\"Processor\")\nfunction processor:process()\n    local gImg = GraphicsImage.new()\n    local dImg = DataImage.new()\nend\nprocessor:register()\n</code></pre>"},{"location":"guide/namespaces/#same-namespace-across-files","title":"Same Namespace Across Files","text":"<p>Classes in the same namespace automatically see each other:</p> Block SyntaxBuilder Syntax <pre><code>-- File: player.lua\nnamespace \"game\"\n\nclass \"Player\" {\n    inventory = null;\n\n    __construct = function(self)\n        self.inventory = Inventory.new()  -- Works!\n    end;\n}\n\n-- File: inventory.lua\nnamespace \"game\"\n\nclass \"Inventory\" {\n    items = {};\n}\n</code></pre> <pre><code>-- File: player.lua\nnamespace \"game\"\n\nlocal player = class(\"Player\")\nplayer.inventory = null\nfunction player:__construct()\n    self.inventory = Inventory.new()  -- Works!\nend\nplayer:register()\n\n-- File: inventory.lua\nnamespace \"game\"\n\nlocal inventory = class(\"Inventory\")\ninventory.items = {}\ninventory:register()\n</code></pre> <p>When you declare <code>namespace \"game\"</code> again, it adds to the existing namespace and automatically imports all classes already defined in it.</p>"},{"location":"guide/namespaces/#inheritance-across-namespaces","title":"Inheritance Across Namespaces","text":"<p>Use full paths or <code>using</code> for cross-namespace inheritance:</p> Block SyntaxBuilder Syntax <pre><code>namespace \"base\"\n\nclass \"Entity\" {\n    id = 0;\n}\n\nnamespace \"game\"\n\nusing \"base.Entity\"\n\nclass \"Player\" extends \"Entity\" {\n    name = \"\";\n}\n\n-- Or with full path:\nclass \"Enemy\" extends \"base.Entity\" {\n    health = 100;\n}\n</code></pre> <pre><code>namespace \"base\"\n\nlocal entity = class(\"Entity\")\nentity.id = 0\nentity:register()\n\nnamespace \"game\"\n\nusing \"base.Entity\"\n\nlocal player = class(\"Player\", {extends = \"Entity\"})\nplayer.name = \"\"\nplayer:register()\n\n-- Or with full path:\nlocal enemy = class(\"Enemy\", {extends = \"base.Entity\"})\nenemy.health = 100\nenemy:register()\n</code></pre> <p>Note</p> <p>All classes are public - any class can inherit from or use any other class regardless of namespace. SIMPLOO does not have private or internal classes.</p>"},{"location":"guide/namespaces/#namespace-with-builder-syntax","title":"Namespace with Builder Syntax","text":"<p>In builder syntax, you can specify the namespace as an argument to <code>class()</code> instead of using the global <code>namespace</code> statement:</p> <pre><code>local config = class(\"Config\", {namespace = \"myapp\"})\nconfig.debug = false\nconfig:register()\n\n-- Results in myapp.Config\nlocal c = myapp.Config.new()\n</code></pre> <p>This is equivalent to:</p> <pre><code>namespace \"myapp\"\n\nlocal config = class(\"Config\")\nconfig.debug = false\nconfig:register()\n</code></pre> <p>The option syntax is useful when you want to define classes in different namespaces without changing the global namespace state.</p>"},{"location":"guide/namespaces/#getting-current-namespace","title":"Getting Current Namespace","text":"<p>Call <code>namespace()</code> without arguments to get the current namespace:</p> <pre><code>namespace \"game.entities\"\n\nprint(namespace())  -- game.entities\n</code></pre>"},{"location":"guide/namespaces/#how-namespaces-map-to-tables","title":"How Namespaces Map to Tables","text":"<p>Namespaces create nested table structures in <code>_G</code> (or your configured base table):</p> <pre><code>namespace \"a.b.c\"\nclass \"MyClass\" {}\n\n-- Equivalent to:\n_G.a = _G.a or {}\n_G.a.b = _G.a.b or {}\n_G.a.b.c = _G.a.b.c or {}\n_G.a.b.c.MyClass = &lt;the class&gt;\n</code></pre>"},{"location":"guide/namespaces/#complete-example","title":"Complete Example","text":"<pre><code>-- utils/math.lua\nnamespace \"utils.math\"\n\nclass \"Vector2\" {\n    x = 0;\n    y = 0;\n\n    __construct = function(self, x, y)\n        self.x = x or 0\n        self.y = y or 0\n    end;\n\n    add = function(self, other)\n        return Vector2.new(self.x + other.x, self.y + other.y)\n    end;\n}\n\n-- game/player.lua\nnamespace \"game\"\n\nusing \"utils.math.Vector2\"\n\nclass \"Player\" {\n    position = null;\n    velocity = null;\n\n    __construct = function(self)\n        self.position = Vector2.new(0, 0)\n        self.velocity = Vector2.new(0, 0)\n    end;\n\n    move = function(self, dx, dy)\n        self.velocity = Vector2.new(dx, dy)\n        self.position = self.position:add(self.velocity)\n    end;\n}\n\n-- main.lua\nlocal player = game.Player.new()\nplayer:move(5, 3)\nprint(player.position.x, player.position.y)  -- 5, 3\n</code></pre>"},{"location":"guide/null-values/","title":"Null Values","text":"<p>Lua tables cannot store <code>nil</code> as a value - assigning <code>nil</code> to a key removes it from the table. SIMPLOO provides the <code>null</code> keyword to handle this.</p>"},{"location":"guide/null-values/#the-problem","title":"The Problem","text":"<p>In plain Lua, you can't store <code>nil</code> in a table:</p> <pre><code>local t = { value = nil }\nprint(t.value)  -- nil\nprint(t[\"value\"])  -- nil\n\n-- But the key doesn't exist:\nfor k, v in pairs(t) do\n    print(k, v)  -- prints nothing\nend\n</code></pre> <p>This causes problems when you want a class member to default to <code>nil</code>:</p> <pre><code>-- This doesn't work as expected\nclass \"Example\" {\n    data = nil;  -- This key won't exist in the class definition\n}\n</code></pre>"},{"location":"guide/null-values/#the-solution-null","title":"The Solution: <code>null</code>","text":"<p>Use <code>null</code> to explicitly set a member's default value to <code>nil</code>:</p> Block SyntaxBuilder Syntax <pre><code>class \"Player\" {\n    name = \"Unknown\";\n    guild = null;  -- Will be nil by default\n    pet = null;    -- Will be nil by default\n}\n</code></pre> <pre><code>local player = class(\"Player\")\nplayer.name = \"Unknown\"\nplayer.guild = null  -- Will be nil by default\nplayer.pet = null    -- Will be nil by default\nplayer:register()\n</code></pre> <pre><code>local p = Player.new()\nprint(p.name)   -- Unknown\nprint(p.guild)  -- nil\nprint(p.pet)    -- nil\n</code></pre>"},{"location":"guide/null-values/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guide/null-values/#optional-references","title":"Optional References","text":"<pre><code>class \"Employee\" {\n    name = \"\";\n    manager = null;  -- May or may not have a manager\n\n    setManager = function(self, mgr)\n        self.manager = mgr\n    end;\n\n    getManagerName = function(self)\n        if self.manager then\n            return self.manager.name\n        end\n        return \"No manager\"\n    end;\n}\n\nlocal alice = Employee.new()\nalice.name = \"Alice\"\n\nlocal bob = Employee.new()\nbob.name = \"Bob\"\nbob:setManager(alice)\n\nprint(alice:getManagerName())  -- No manager\nprint(bob:getManagerName())    -- Alice\n</code></pre>"},{"location":"guide/null-values/#lazy-initialization","title":"Lazy Initialization","text":"<pre><code>class \"DataLoader\" {\n    cache = null;  -- Not loaded yet\n\n    get = function(self)\n        if self.cache == nil then\n            self.cache = self:loadFromDisk()\n        end\n        return self.cache\n    end;\n\n    loadFromDisk = function(self)\n        print(\"Loading data...\")\n        return { \"item1\", \"item2\", \"item3\" }\n    end;\n}\n\nlocal loader = DataLoader.new()\nprint(loader.cache)  -- nil\nloader:get()         -- Loading data...\nprint(#loader.cache) -- 3\nloader:get()         -- (no output, already loaded)\n</code></pre>"},{"location":"guide/null-values/#what-is-null","title":"What is <code>null</code>?","text":"<p><code>null</code> is a special marker value that SIMPLOO recognizes. During class registration, any member with value <code>null</code> is converted to <code>nil</code>.</p> <pre><code>print(null)  -- NullVariable_WgVtlrvpP194T7wUWDWv2mjB\n</code></pre> <p>Note</p> <p>Never compare values against <code>null</code> at runtime. Use <code>nil</code> for comparisons:</p> <pre><code>-- Correct\nif self.data == nil then\n\n-- Wrong (will never be true for actual nil values)\nif self.data == null then\n</code></pre>"},{"location":"guide/null-values/#complete-example","title":"Complete Example","text":"Block SyntaxBuilder Syntax <pre><code>dofile(\"simploo.lua\")\n\nclass \"TreeNode\" {\n    value = 0;\n    left = null;\n    right = null;\n\n    __construct = function(self, val)\n        self.value = val\n    end;\n\n    insert = function(self, val)\n        if val &lt; self.value then\n            if self.left == nil then\n                self.left = TreeNode.new(val)\n            else\n                self.left:insert(val)\n            end\n        else\n            if self.right == nil then\n                self.right = TreeNode.new(val)\n            else\n                self.right:insert(val)\n            end\n        end\n    end;\n\n    printInOrder = function(self)\n        if self.left then self.left:printInOrder() end\n        print(self.value)\n        if self.right then self.right:printInOrder() end\n    end;\n}\n\nlocal root = TreeNode.new(5)\nroot:insert(3)\nroot:insert(7)\nroot:insert(1)\nroot:insert(9)\n\nroot:printInOrder()\n-- Output: 1, 3, 5, 7, 9\n</code></pre> <pre><code>dofile(\"simploo.lua\")\n\nlocal node = class(\"TreeNode\")\nnode.value = 0\nnode.left = null\nnode.right = null\n\nfunction node:__construct(val)\n    self.value = val\nend\n\nfunction node:insert(val)\n    if val &lt; self.value then\n        if self.left == nil then\n            self.left = TreeNode.new(val)\n        else\n            self.left:insert(val)\n        end\n    else\n        if self.right == nil then\n            self.right = TreeNode.new(val)\n        else\n            self.right:insert(val)\n        end\n    end\nend\n\nfunction node:printInOrder()\n    if self.left then self.left:printInOrder() end\n    print(self.value)\n    if self.right then self.right:printInOrder() end\nend\n\nnode:register()\n\nlocal root = TreeNode.new(5)\nroot:insert(3)\nroot:insert(7)\nroot:insert(1)\nroot:insert(9)\n\nroot:printInOrder()\n-- Output: 1, 3, 5, 7, 9\n</code></pre>"},{"location":"guide/polymorphism/","title":"Polymorphism","text":"<p>Polymorphism allows child classes to override parent methods, and have those overrides called even when invoked from parent code. This is fundamental to object-oriented programming and enables powerful design patterns.</p>"},{"location":"guide/polymorphism/#how-it-works","title":"How It Works","text":"<p>When a parent method calls <code>self:someMethod()</code>, SIMPLOO looks up the method starting from the actual instance's class. If the child overrides that method, the child's version is called:</p> <pre><code>class \"Animal\" {\n    speak = function(self)\n        return \"...\"\n    end;\n\n    introduce = function(self)\n        return \"I say: \" .. self:speak()  -- Polymorphic call\n    end;\n}\n\nclass \"Dog\" extends \"Animal\" {\n    speak = function(self)\n        return \"woof!\"\n    end;\n}\n\nclass \"Cat\" extends \"Animal\" {\n    speak = function(self)\n        return \"meow!\"\n    end;\n}\n\nlocal dog = Dog.new()\nlocal cat = Cat.new()\n\nprint(dog:introduce())  -- I say: woof!\nprint(cat:introduce())  -- I say: meow!\n</code></pre> <p>The parent's <code>introduce()</code> method calls <code>self:speak()</code>, but since <code>self</code> is a <code>Dog</code> or <code>Cat</code> instance, the child's override is used.</p>"},{"location":"guide/polymorphism/#calling-parent-methods","title":"Calling Parent Methods","text":"<p>Use <code>self.ParentName:method()</code> to explicitly call the parent's version:</p> <pre><code>class \"Animal\" {\n    speak = function(self)\n        return \"generic sound\"\n    end;\n}\n\nclass \"Dog\" extends \"Animal\" {\n    speak = function(self)\n        return \"woof\"\n    end;\n\n    -- Can still access parent's version\n    parentSpeak = function(self)\n        return self.Animal:speak()\n    end;\n}\n\nlocal dog = Dog.new()\nprint(dog:speak())        -- woof\nprint(dog:parentSpeak())  -- generic sound\n</code></pre>"},{"location":"guide/polymorphism/#chaining-parent-calls","title":"Chaining Parent Calls","text":"<p>Each level can call its parent, building up results:</p> <pre><code>class \"A\" {\n    getValue = function(self)\n        return \"A\"\n    end;\n}\n\nclass \"B\" extends \"A\" {\n    getValue = function(self)\n        return \"B+\" .. self.A:getValue()\n    end;\n}\n\nclass \"C\" extends \"B\" {\n    getValue = function(self)\n        return \"C+\" .. self.B:getValue()\n    end;\n}\n\nlocal c = C.new()\nprint(c:getValue())  -- C+B+A\n</code></pre>"},{"location":"guide/polymorphism/#deep-inheritance","title":"Deep Inheritance","text":"<p>Polymorphism works through any depth of inheritance:</p> <pre><code>class \"Base\" {\n    getName = function(self)\n        return \"base\"\n    end;\n\n    callGetName = function(self)\n        return self:getName()\n    end;\n}\n\nclass \"Middle\" extends \"Base\" {\n    getName = function(self)\n        return \"middle\"\n    end;\n}\n\nclass \"Leaf\" extends \"Middle\" {\n    getName = function(self)\n        return \"leaf\"\n    end;\n}\n\nlocal leaf = Leaf.new()\nprint(leaf:callGetName())  -- leaf (calls Leaf's getName)\n\nlocal middle = Middle.new()\nprint(middle:callGetName())  -- middle (calls Middle's getName)\n</code></pre>"},{"location":"guide/polymorphism/#multiple-inheritance","title":"Multiple Inheritance","text":"<p>Polymorphism works across multiple parent classes. A child can override methods from any parent, and methods from one parent can call methods inherited from another:</p> <pre><code>class \"Describable\" {\n    getDescription = function(self)\n        return \"unknown\"\n    end;\n\n    describe = function(self)\n        return \"I am: \" .. self:getDescription()\n    end;\n}\n\nclass \"Identifiable\" {\n    id = 0;\n\n    getId = function(self)\n        return self.id\n    end;\n}\n\nclass \"Entity\" extends \"Describable, Identifiable\" {\n    name = \"\";\n\n    __construct = function(self, id, name)\n        self.id = id\n        self.name = name\n    end;\n\n    -- Override from Describable, uses method from Identifiable\n    getDescription = function(self)\n        return self.name .. \" (id:\" .. self:getId() .. \")\"\n    end;\n}\n\nlocal e = Entity.new(42, \"Player\")\nprint(e:describe())  -- I am: Player (id:42)\n</code></pre>"},{"location":"guide/polymorphism/#polymorphism-in-constructors","title":"Polymorphism in Constructors","text":"<p>When a parent constructor calls a virtual method, the child's override is used. Child members are initialized to their declared default values before any constructor runs, so the override can safely access them:</p> <pre><code>class \"Widget\" {\n    name = \"\";\n\n    __construct = function(self)\n        self.name = self:getName()  -- Polymorphic call\n    end;\n\n    getName = function(self)\n        return \"Widget\"\n    end;\n}\n\nclass \"Button\" extends \"Widget\" {\n    label = \"Click me\";\n\n    getName = function(self)\n        return \"Button:\" .. self.label\n    end;\n}\n\nlocal btn = Button.new()\nprint(btn.name)  -- Button:Click me\n</code></pre> <p>Note</p> <p>If the child has its own constructor that modifies members, those changes happen after the parent constructor runs. The parent constructor sees the declared default values, not values set by the child constructor.</p>"},{"location":"guide/polymorphism/#design-patterns","title":"Design Patterns","text":"<p>Polymorphism enables many classic design patterns. Here are a few examples:</p>"},{"location":"guide/polymorphism/#template-method-pattern","title":"Template Method Pattern","text":"<p>Define an algorithm skeleton in the parent, let children fill in the steps:</p> <pre><code>class \"DataProcessor\" {\n    -- Template method - defines the algorithm\n    process = function(self)\n        local data = self:fetchData()\n        local transformed = self:transform(data)\n        return self:format(transformed)\n    end;\n\n    fetchData = function(self)\n        return \"raw\"\n    end;\n\n    transform = function(self, data)\n        return data\n    end;\n\n    format = function(self, data)\n        return \"[\" .. data .. \"]\"\n    end;\n}\n\nclass \"JsonProcessor\" extends \"DataProcessor\" {\n    transform = function(self, data)\n        return '{\"data\":\"' .. data .. '\"}'\n    end;\n}\n\nlocal json = JsonProcessor.new()\nprint(json:process())  -- [{\"data\":\"raw\"}]\n</code></pre>"},{"location":"guide/polymorphism/#factory-method-pattern","title":"Factory Method Pattern","text":"<p>Let subclasses decide which objects to create:</p> <pre><code>class \"Document\" {\n    content = \"\";\n\n    createPage = function(self)\n        return \"GenericPage\"\n    end;\n\n    addContent = function(self, text)\n        self.content = self.content .. self:createPage() .. \":\" .. text .. \"\\n\"\n    end;\n}\n\nclass \"Report\" extends \"Document\" {\n    createPage = function(self)\n        return \"ReportPage\"\n    end;\n}\n\nlocal report = Report.new()\nreport:addContent(\"Q1 Sales\")\nprint(report.content)  -- ReportPage:Q1 Sales\n</code></pre>"},{"location":"guide/polymorphism/#state-pattern","title":"State Pattern","text":"<p>Change behavior by swapping state objects:</p> <pre><code>class \"State\" {\n    handle = function(self, context)\n        return \"default\"\n    end;\n}\n\nclass \"IdleState\" extends \"State\" {\n    handle = function(self, context)\n        return \"idle\"\n    end;\n}\n\nclass \"RunningState\" extends \"State\" {\n    handle = function(self, context)\n        return \"running at \" .. context.speed\n    end;\n}\n\nclass \"Machine\" {\n    state = null;\n    speed = 100;\n\n    __construct = function(self)\n        self.state = IdleState.new()\n    end;\n\n    setState = function(self, state)\n        self.state = state\n    end;\n\n    process = function(self)\n        return self.state:handle(self)\n    end;\n}\n\nlocal m = Machine.new()\nprint(m:process())  -- idle\n\nm:setState(RunningState.new())\nprint(m:process())  -- running at 100\n</code></pre>"},{"location":"guide/polymorphism/#visitor-pattern","title":"Visitor Pattern","text":"<p>Double dispatch for operations on object structures:</p> <pre><code>class \"Visitor\" {\n    visitCircle = function(self, circle) return 0 end;\n    visitSquare = function(self, square) return 0 end;\n}\n\nclass \"AreaVisitor\" extends \"Visitor\" {\n    visitCircle = function(self, circle)\n        return 3.14 * circle.radius * circle.radius\n    end;\n\n    visitSquare = function(self, square)\n        return square.side * square.side\n    end;\n}\n\nclass \"Shape\" {\n    accept = function(self, visitor)\n        return 0\n    end;\n}\n\nclass \"Circle\" extends \"Shape\" {\n    radius = 0;\n\n    __construct = function(self, r)\n        self.radius = r\n    end;\n\n    accept = function(self, visitor)\n        return visitor:visitCircle(self)\n    end;\n}\n\nclass \"Square\" extends \"Shape\" {\n    side = 0;\n\n    __construct = function(self, s)\n        self.side = s\n    end;\n\n    accept = function(self, visitor)\n        return visitor:visitSquare(self)\n    end;\n}\n\nlocal shapes = {Circle.new(2), Square.new(3)}\nlocal areaVisitor = AreaVisitor.new()\n\nfor _, shape in ipairs(shapes) do\n    print(shape:accept(areaVisitor))\nend\n-- 12.56\n-- 9\n</code></pre>"},{"location":"guide/polymorphism/#private-members-and-polymorphism","title":"Private Members and Polymorphism","text":"<p>Private members are correctly scoped - each class accesses its own privates, even during polymorphic calls:</p> <pre><code>class \"Parent\" {\n    private {\n        secret = \"parent secret\";\n    };\n\n    public {\n        getSecret = function(self)\n            return self.secret\n        end;\n    };\n}\n\nclass \"Child\" extends \"Parent\" {\n    private {\n        secret = \"child secret\";\n    };\n\n    public {\n        getChildSecret = function(self)\n            return self.secret\n        end;\n\n        callParentGetSecret = function(self)\n            return self.Parent:getSecret()\n        end;\n    };\n}\n\nlocal c = Child.new()\nprint(c:getSecret())            -- parent secret\nprint(c:getChildSecret())       -- child secret\nprint(c:callParentGetSecret())  -- parent secret\n</code></pre> <p>The parent's <code>getSecret()</code> accesses the parent's private <code>secret</code>, not the child's, even when called on a child instance.</p>"},{"location":"guide/statics/","title":"Static Members","text":"<p>Static members are shared across all instances of a class. Changes to a static member affect every instance.</p>"},{"location":"guide/statics/#static-variables","title":"Static Variables","text":"<p>A static variable has one value shared by all instances:</p> Block SyntaxBuilder Syntax <pre><code>class \"Counter\" {\n    static {\n        count = 0;\n    };\n\n    __construct = function(self)\n        self.count = self.count + 1\n    end;\n\n    public {\n        getCount = function(self)\n            return self.count\n        end;\n    };\n}\n</code></pre> <pre><code>local counter = class(\"Counter\")\ncounter.static.count = 0\n\nfunction counter:__construct()\n    self.count = self.count + 1\nend\n\nfunction counter.public:getCount()\n    return self.count\nend\n\ncounter:register()\n</code></pre> <pre><code>local a = Counter.new()\nprint(a:getCount())  -- 1\n\nlocal b = Counter.new()\nprint(b:getCount())  -- 2\n\nlocal c = Counter.new()\nprint(c:getCount())  -- 3\n\n-- All instances see the same value\nprint(a:getCount())  -- 3\n</code></pre>"},{"location":"guide/statics/#accessing-static-members","title":"Accessing Static Members","text":"<p>Static members can be accessed from both instances and the class itself:</p> <pre><code>class \"Config\" {\n    static {\n        maxPlayers = 100;\n        serverName = \"My Server\";\n    };\n}\n\n-- Access from class\nprint(Config.maxPlayers)    -- 100\nprint(Config.serverName)    -- My Server\n\n-- Access from instance\nlocal c = Config.new()\nprint(c.maxPlayers)         -- 100\n\n-- Changes affect everything\nConfig.maxPlayers = 50\nprint(c.maxPlayers)         -- 50 (same value)\n</code></pre>"},{"location":"guide/statics/#static-methods","title":"Static Methods","text":"<p>Static methods don't require an instance and can be called directly on the class:</p> Block SyntaxBuilder Syntax <pre><code>class \"MathUtils\" {\n    static {\n        PI = 3.14159;\n\n        circleArea = function(self, radius)\n            return self.PI * radius * radius\n        end;\n\n        circleCircumference = function(self, radius)\n            return 2 * self.PI * radius\n        end;\n    };\n}\n</code></pre> <pre><code>local utils = class(\"MathUtils\")\nutils.static.PI = 3.14159\n\nfunction utils.static:circleArea(radius)\n    return self.PI * radius * radius\nend\n\nfunction utils.static:circleCircumference(radius)\n    return 2 * self.PI * radius\nend\n\nutils:register()\n</code></pre> <pre><code>-- Call directly on class\nprint(MathUtils:circleArea(5))          -- 78.53975\nprint(MathUtils:circleCircumference(5)) -- 31.4159\n\n-- Or on an instance (less common)\nlocal m = MathUtils.new()\nprint(m:circleArea(5))  -- 78.53975\n</code></pre>"},{"location":"guide/statics/#private-static","title":"Private Static","text":"<p>Combine <code>private</code> and <code>static</code> for shared internal state:</p> Block SyntaxBuilder Syntax <pre><code>class \"IdGenerator\" {\n    private {\n        static {\n            nextId = 1;\n        };\n    };\n\n    public {\n        static {\n            generate = function(self)\n                local id = self.nextId\n                self.nextId = self.nextId + 1\n                return id\n            end;\n\n            reset = function(self)\n                self.nextId = 1\n            end;\n        };\n    };\n}\n</code></pre> <pre><code>local gen = class(\"IdGenerator\")\ngen.private.static.nextId = 1\n\nfunction gen.public.static:generate()\n    local id = self.nextId\n    self.nextId = self.nextId + 1\n    return id\nend\n\nfunction gen.public.static:reset()\n    self.nextId = 1\nend\n\ngen:register()\n</code></pre> <pre><code>print(IdGenerator:generate())  -- 1\nprint(IdGenerator:generate())  -- 2\nprint(IdGenerator:generate())  -- 3\n\n-- Cannot access private static directly\nprint(IdGenerator.nextId)  -- Error: accessing private member\n\nIdGenerator:reset()\nprint(IdGenerator:generate())  -- 1\n</code></pre>"},{"location":"guide/statics/#static-vs-instance-members","title":"Static vs Instance Members","text":"<p>Understanding the difference:</p> <pre><code>class \"Example\" {\n    static {\n        sharedValue = 0;\n    };\n\n    instanceValue = 0;\n}\n\nlocal a = Example.new()\nlocal b = Example.new()\n\n-- Instance values are separate\na.instanceValue = 10\nb.instanceValue = 20\nprint(a.instanceValue)  -- 10\nprint(b.instanceValue)  -- 20\n\n-- Static values are shared\na.sharedValue = 100\nprint(b.sharedValue)    -- 100 (same value!)\nprint(Example.sharedValue)  -- 100\n</code></pre>"},{"location":"guide/statics/#static-initializer-__register","title":"Static Initializer: <code>__register</code>","text":"<p>The <code>__register</code> method runs once when the class is defined. Use it to initialize static members that require computation or to register the class somewhere.</p> Block SyntaxBuilder Syntax <pre><code>class \"Enemy\" {\n    static {\n        allEnemies = {};\n        nextId = 0;\n    };\n\n    __register = function(self)\n        self.nextId = loadNextIdFromDatabase()\n        registerClass(self)\n    end;\n}\n</code></pre> <pre><code>local enemy = class(\"Enemy\")\nenemy.static.allEnemies = {}\nenemy.static.nextId = 0\n\nenemy.__register = function(self)\n    self.nextId = loadNextIdFromDatabase()\n    registerClass(self)\nend\n\nenemy:register()\n</code></pre> <p>This is similar to Java's <code>static {}</code> initializer block. The <code>self</code> parameter refers to the class itself, not an instance.</p>"},{"location":"guide/statics/#memory-efficiency","title":"Memory Efficiency","text":"<p>Static members are not copied when creating new instances, saving memory for large data:</p> <pre><code>class \"Game\" {\n    static {\n        -- This large table is shared, not copied\n        levelData = {\n            -- lots of level configuration...\n        };\n    };\n\n    currentLevel = 1;  -- This is copied per instance\n}\n\n-- Creating 1000 players doesn't duplicate levelData\nfor i = 1, 1000 do\n    Game.new()\nend\n</code></pre>"},{"location":"guide/statics/#complete-example","title":"Complete Example","text":"Block SyntaxBuilder Syntax <pre><code>dofile(\"simploo.lua\")\n\nclass \"Player\" {\n    private {\n        static {\n            allPlayers = {};\n        };\n    };\n\n    public {\n        static {\n            getPlayerCount = function(self)\n                return #self.allPlayers\n            end;\n\n            getAllPlayers = function(self)\n                return self.allPlayers\n            end;\n\n            broadcast = function(self, message)\n                for _, player in ipairs(self.allPlayers) do\n                    player:receive(message)\n                end\n            end;\n        };\n\n        name = \"\";\n\n        __construct = function(self, playerName)\n            self.name = playerName\n            table.insert(self.allPlayers, self)\n            print(self.name .. \" joined. Total players: \" .. #self.allPlayers)\n        end;\n\n        receive = function(self, message)\n            print(\"[\" .. self.name .. \"] \" .. message)\n        end;\n    };\n}\n\nlocal alice = Player.new(\"Alice\")   -- Alice joined. Total players: 1\nlocal bob = Player.new(\"Bob\")       -- Bob joined. Total players: 2\nlocal charlie = Player.new(\"Charlie\") -- Charlie joined. Total players: 3\n\nprint(Player:getPlayerCount())  -- 3\n\nPlayer:broadcast(\"Game starting!\")\n-- [Alice] Game starting!\n-- [Bob] Game starting!\n-- [Charlie] Game starting!\n</code></pre> <pre><code>dofile(\"simploo.lua\")\n\nlocal player = class(\"Player\")\nplayer.private.static.allPlayers = {}\nplayer.public.name = \"\"\n\nfunction player.public.static:getPlayerCount()\n    return #self.allPlayers\nend\n\nfunction player.public.static:getAllPlayers()\n    return self.allPlayers\nend\n\nfunction player.public.static:broadcast(message)\n    for _, p in ipairs(self.allPlayers) do\n        p:receive(message)\n    end\nend\n\nfunction player.public:__construct(playerName)\n    self.name = playerName\n    table.insert(self.allPlayers, self)\n    print(self.name .. \" joined. Total players: \" .. #self.allPlayers)\nend\n\nfunction player.public:receive(message)\n    print(\"[\" .. self.name .. \"] \" .. message)\nend\n\nplayer:register()\n\nlocal alice = Player.new(\"Alice\")   -- Alice joined. Total players: 1\nlocal bob = Player.new(\"Bob\")       -- Bob joined. Total players: 2\nlocal charlie = Player.new(\"Charlie\") -- Charlie joined. Total players: 3\n\nprint(Player:getPlayerCount())  -- 3\n\nPlayer:broadcast(\"Game starting!\")\n-- [Alice] Game starting!\n-- [Bob] Game starting!\n-- [Charlie] Game starting!\n</code></pre>"},{"location":"reference/ai-agent/","title":"AI Agent Reference","text":"<p>AI Agent Reference</p> <p>This is a condensed reference for AI coding agents. For human-readable documentation with detailed explanations and examples, see the Guide.</p>"},{"location":"reference/ai-agent/#simploo-ai-agent-reference","title":"SIMPLOO AI Agent Reference","text":"<p>Lua OOP library with two equivalent syntaxes: block and builder.</p> <p>IMPORTANT: Before writing code, examine existing codebase files to determine which syntax is used. Match the existing style. Do not mix syntaxes within a project.</p>"},{"location":"reference/ai-agent/#class-definition","title":"Class Definition","text":"<pre><code>-- Block syntax (auto-registers)\nclass \"Name\" { member = value; method = function(self) end; }\n\n-- Builder syntax (manual register)\nlocal c = class(\"Name\")\nc.member = value\nfunction c:method() end\nc:register()  -- required\n</code></pre>"},{"location":"reference/ai-agent/#inheritance","title":"Inheritance","text":"<pre><code>class \"Child\" extends \"Parent\" {}\nclass \"Multi\" extends \"A, B, C\" {}  -- multiple inheritance\n\n-- Builder\nclass(\"Child\", {extends = \"Parent\"})\n</code></pre>"},{"location":"reference/ai-agent/#interfaces","title":"Interfaces","text":"<pre><code>interface \"IName\" {\n    requiredMethod = function(self, arg) end;  -- empty body = signature only\n    default { optionalMethod = function(self) return \"default\" end; };\n}\n\ninterface \"IChild\" extends \"IParent\" {}  -- interface inheritance\n\nclass \"Impl\" implements \"IFace1, IFace2\" {\n    requiredMethod = function(self, arg) ... end;\n}\n\n-- Combined\nclass \"X\" extends \"Parent\" implements \"IFace\" {}\n\n-- Builder\nlocal i = interface(\"IName\")\ni.requiredMethod = function(self, arg) end\ni.default.optionalMethod = function(self) return \"default\" end\ni:register()\n\nlocal c = class(\"Impl\", {implements = \"IFace1, IFace2\"})\nfunction c:requiredMethod(arg) ... end\nc:register()\n</code></pre> <p>Interface restrictions: - Only public methods allowed (no private/protected/static) - No variables (only functions) - <code>instance_of(InterfaceName)</code> works for checking implementation - Interface reference (<code>self.IName</code>) only exists when interface has default methods - Calling default from override: <code>self.InterfaceName:method()</code> - Interfaces cannot be instantiated: <code>IName.new()</code> errors</p>"},{"location":"reference/ai-agent/#modifiers","title":"Modifiers","text":"<p>Apply via nesting. Order irrelevant.</p> <pre><code>class \"Ex\" {\n    public { x = 1; };           -- accessible everywhere (default if omitted)\n    private { y = 2; };          -- declaring class only\n    protected { z = 3; };        -- declaring class + subclasses\n    static { count = 0; };       -- shared across instances\n    const { MAX = 100; };        -- immutable after init\n    transient { cache = {}; };   -- excluded from serialization\n    meta { __tostring = function(self) return \"str\" end; };  -- metamethod\n\n    -- Combine modifiers by nesting\n    private { static { secret = \"x\"; }; };\n    public { static { const { VERSION = \"1.0\"; }; }; };\n}\n\n-- Builder syntax\nc.private.static.secret = \"x\"\nc.public.static.const.VERSION = \"1.0\"\n</code></pre>"},{"location":"reference/ai-agent/#constructorsfinalizers","title":"Constructors/Finalizers","text":"<pre><code>class \"Ex\" {\n    __construct = function(self, arg1, arg2) end;  -- called on new()\n    __finalize = function(self) end;               -- called on GC\n    __register = function(self) end;                 -- called once at class registration (self = class)\n}\n\n-- Builder\nlocal c = class(\"Ex\")\nfunction c:__construct(arg1, arg2) end\nfunction c:__finalize() end\nfunction c:__register() end\nc:register()\n\n-- Usage: instantiation (same for both syntaxes, all equivalent)\nlocal obj = Ex.new(a, b)\nlocal obj = Ex:new(a, b)\nlocal obj = Ex(a, b)\n</code></pre>"},{"location":"reference/ai-agent/#parent-access","title":"Parent Access","text":"<pre><code>class \"Child\" extends \"Parent\" {\n    __construct = function(self, x)\n        self.Parent(x)  -- call parent constructor (dev mode warns if forgotten)\n        -- OR: self.Parent:__construct(x)\n    end;\n    method = function(self)\n        return self.Parent:method()  -- call parent method\n    end;\n}\n</code></pre> <p>Constructor rules: - Parent constructor NOT auto-called if child defines own constructor - Parent constructor called once max (subsequent calls are no-op) - Dev mode warns if parent constructor has <code>__construct</code> but child doesn't call it - No warning if parent has no constructor or child has no constructor</p> <p>Deep inheritance with varargs: <pre><code>class \"Level3\" extends \"Level2\" {\n    __construct = function(self, myArg, ...)\n        self.Level2(...)  -- pass remaining args to parent\n        self.myValue = myArg\n    end;\n}\n</code></pre></p>"},{"location":"reference/ai-agent/#namespaces","title":"Namespaces","text":"<pre><code>namespace \"game.entities\"\nclass \"Player\" {}  -- creates game.entities.Player\n\nusing \"other.ns.Class\"      -- import single class\nusing \"other.ns.*\"          -- import all from namespace\nusing \"other.ns.X\" as \"Y\"   -- import with alias\n\nnamespace \"\"  -- return to global namespace\nnamespace()   -- get current namespace (no args)\n\n-- Builder: namespace in options\nclass(\"Config\", {namespace = \"myapp\"})\n</code></pre> <p>Same namespace across files: re-declaring <code>namespace \"x\"</code> auto-imports existing classes in <code>x</code>.</p> <p>Classes can reference themselves by short name within methods.</p>"},{"location":"reference/ai-agent/#null-values","title":"Null Values","text":"<pre><code>class \"Ex\" { optionalRef = null; }  -- declares member with nil default\n-- Use nil for comparisons: if self.optionalRef == nil then\n-- Never compare against null at runtime\n</code></pre>"},{"location":"reference/ai-agent/#instance-methods","title":"Instance Methods","text":"<p>Usage (same for both syntaxes): <pre><code>obj:get_name()           -- \"ClassName\" or \"ns.ClassName\"\nobj:get_class()          -- class reference\nobj:instance_of(Other)   -- true if obj is/extends/implements Other (also accepts \"ClassName\" string)\nobj:get_parents()        -- {ParentName = parentInstance, ...}\nobj:get_member(\"name\")   -- {value, owner, modifiers} or nil\nobj:get_members()        -- {name = {value, owner, modifiers}, ...}\nobj:bind(fn)             -- wrap callback to preserve private/protected access\nobj:serialize()          -- {ClassName={member=value, Parent={...}}}\nobj:clone()              -- deep copy (faster than serialize/deserialize, includes transient)\n</code></pre></p>"},{"location":"reference/ai-agent/#serialization","title":"Serialization","text":"<p>Usage (same for both syntaxes): <pre><code>local data = simploo.serialize(instance)  -- or instance:serialize()\nlocal obj = simploo.deserialize(data)     -- or ClassName:deserialize(data)\n</code></pre></p> <p>Serializes: public/private/protected non-static non-function non-transient members. Output: <code>{ClassName = {members..., ParentName = {parent members...}}}</code>. Consistent structure at all levels.</p>"},{"location":"reference/ai-agent/#metamethods","title":"Metamethods","text":"<p>Mark with <code>meta</code> modifier: <pre><code>class \"Ex\" {\n    meta {\n        __tostring = function(self) return \"str\" end;\n        __call = function(self, ...) end;  -- instance(args) after construction\n        __add = function(self, other) end;\n        __sub = function(self, other) end;\n        __mul = function(self, other) end;\n        __div = function(self, other) end;\n        __mod = function(self, other) end;\n        __pow = function(self, other) end;\n        __unm = function(self) end;\n        __eq = function(self, other) end;\n        __lt = function(self, other) end;\n        __le = function(self, other) end;\n        __concat = function(self, other) end;\n        __index = function(self, key) end;\n        __newindex = function(self, key, val) end;\n    };\n}\n\n-- Builder\nlocal c = class(\"Ex\")\nc.meta.__tostring = function(self) return \"str\" end\nc.meta.__add = function(self, other) end\nc:register()\n</code></pre></p> <p>Note: First call <code>Class(args)</code> invokes <code>__construct</code>. Subsequent <code>instance(args)</code> invokes <code>__call</code>.</p> <p>Metamethods are inherited from parent classes.</p>"},{"location":"reference/ai-agent/#static-members","title":"Static Members","text":"<pre><code>class \"Counter\" {\n    static { count = 0; };\n    __construct = function(self) self.count = self.count + 1 end;\n}\n\n-- Builder\nlocal c = class(\"Counter\")\nc.static.count = 0\nfunction c:__construct() self.count = self.count + 1 end\nc:register()\n\n-- Usage (same for both syntaxes)\nCounter.count  -- access on class\ninstance.count -- same value, shared\n</code></pre> <p>Static members: - Not copied per instance (memory efficient for large data) - Accessible via both class and instance - Changes propagate to all instances and class</p>"},{"location":"reference/ai-agent/#polymorphism","title":"Polymorphism","text":"<p>Child overrides called even from parent code: <pre><code>class \"Base\" {\n    template = function(self) return self:hook() end;  -- calls child's hook\n    hook = function(self) return \"base\" end;\n}\nclass \"Derived\" extends \"Base\" {\n    hook = function(self) return \"derived\" end;\n}\nDerived():template()  -- \"derived\"\n</code></pre></p> <p>Polymorphism in constructors: child overrides are called during parent constructor, but child members have their declared default values (child constructor hasn't run yet).</p>"},{"location":"reference/ai-agent/#access-control-notes","title":"Access Control Notes","text":"<ul> <li>Production mode: no access checks, maximum performance</li> <li>Development mode: private/protected enforced via scope tracking</li> <li>Private members: class-scoped (parent's private separate from child's private with same name)</li> <li>Cross-instance: same class CAN access other instance's private (class-based, like Java/C++)</li> <li><code>bind(fn)</code>: preserves scope for callbacks passed to other classes</li> <li>Coroutine-safe: scope tracked per-thread</li> </ul>"},{"location":"reference/ai-agent/#ambiguous-members","title":"Ambiguous Members","text":"<p>Multiple parents with same member name: <pre><code>class \"Both\" extends \"Left, Right\" {}\nobj.value      -- ERROR: ambiguous\nobj.Left.value -- OK\nobj.Right.value -- OK\n-- Or override in child to resolve\n</code></pre></p> <p>Parents with same short name from different namespaces: <pre><code>class \"Child\" extends \"ns1.Foo, ns2.Foo\" {}\nobj.Foo              -- nil (ambiguous)\nobj[\"ns1.Foo\"]:method()  -- OK via bracket notation\nobj[\"ns2.Foo\"]:method()  -- OK\n-- Or use 'using ... as' for aliases\n</code></pre></p>"},{"location":"reference/ai-agent/#shadowing","title":"Shadowing","text":"<p>Child public variables shadow parent's: <pre><code>class \"Parent\" { value = \"parent\"; }\nclass \"Child\" extends \"Parent\" { value = \"child\"; }\nChild.new().value        -- \"child\"\nChild.new().Parent.value -- \"parent\"\n</code></pre></p>"},{"location":"reference/ai-agent/#configuration","title":"Configuration","text":"<p>Set before loading simploo: <pre><code>simploo = {config = {}}\nsimploo.config[\"production\"] = true       -- disable access checks (faster)\nsimploo.config[\"classHotswap\"] = true     -- update existing instances on redefine\nsimploo.config[\"exposeSyntax\"] = true     -- globals: class, extends, etc.\nsimploo.config[\"baseInstanceTable\"] = _G  -- where classes stored\nsimploo.config[\"baseSyntaxTable\"] = _G    -- where syntax exposed\nsimploo.config[\"customModifiers\"] = {}    -- e.g., {\"observable\"}\nsimploo.config[\"strictInterfaces\"] = false -- check arg names/count (Lua 5.2+ only)\ndofile(\"simploo.lua\")\n\n-- Runtime syntax toggle\nsimploo.syntax.init()     -- expose syntax globals\nsimploo.syntax.destroy()  -- remove syntax globals\n\n-- Manual hotswap init (alternative to config)\nsimploo.hotswap:init()\n</code></pre></p> <p>Custom syntax/instance tables: <pre><code>local myLib = {}\nsimploo.config[\"baseSyntaxTable\"] = myLib\nsimploo.config[\"baseInstanceTable\"] = myLib\n-- Extract to locals for chainable syntax:\nlocal class, extends = myLib.class, myLib.extends\nclass \"Player\" extends \"Entity\" {}\n</code></pre></p>"},{"location":"reference/ai-agent/#hooks","title":"Hooks","text":"<pre><code>simploo.hook:add(\"hookName\", function(...) return modified end)\nsimploo.hook:remove(\"hookName\", callbackFn)  -- or omit fn to remove all\nsimploo.hook:fire(\"hookName\", ...)\n\n-- Available hooks:\n-- beforeRegister(data) -&gt; data  -- modify class/interface definition\n-- afterRegister(data, baseInstance)\n-- afterNew(instance) -&gt; instance\n-- onNamespace(name) -&gt; name\n-- onUsing(path) -&gt; path\n</code></pre> <p>Hook data structure for beforeRegister: <pre><code>{\n    type = \"class\",  -- or \"interface\"\n    name = \"ClassName\",\n    parents = {\"Parent1\", \"Parent2\"},\n    implements = {\"IFace1\"},\n    members = {\n        memberName = {\n            value = &lt;value&gt;,\n            modifiers = {public = true, static = false, ...}\n        }\n    }\n}\n</code></pre></p> <p>Multiple hooks: run in registration order, each receives previous hook's return value.</p>"},{"location":"reference/ai-agent/#hotswap","title":"Hotswap","text":"<p>When class redefined with hotswap enabled: - New members added with default values - Removed members become nil - Methods replaced with new implementations - Existing non-function values preserved (not reset to new defaults) - Works with inheritance</p>"},{"location":"reference/ai-agent/#common-patterns","title":"Common Patterns","text":"<pre><code>-- Factory\nclass \"Factory\" {\n    static { create = function(self, type) return self.types[type]() end; };\n}\n\n-- Singleton\nclass \"Singleton\" {\n    private { static { instance = null; }; };\n    static { get = function(self)\n        if not self.instance then self.instance = self() end\n        return self.instance\n    end; };\n}\n\n-- Template method\nclass \"Base\" {\n    algorithm = function(self) self:step1(); self:step2() end;\n    step1 = function(self) end;  -- override in child\n    step2 = function(self) end;\n}\n</code></pre>"},{"location":"reference/config/","title":"Configuration","text":"<p>SIMPLOO behavior can be customized through configuration options. Set these before loading SIMPLOO.</p>"},{"location":"reference/config/#setting-configuration","title":"Setting Configuration","text":"<pre><code>-- Set before loading SIMPLOO\nsimploo = {config = {}}\nsimploo.config[\"production\"] = true\nsimploo.config[\"classHotswap\"] = true\n\ndofile(\"simploo.lua\")\n</code></pre>"},{"location":"reference/config/#options","title":"Options","text":""},{"location":"reference/config/#production","title":"production","text":"<p>Enables production mode, which disables safety checks for better performance.</p> Type <code>boolean</code> Default <code>false</code> <pre><code>simploo.config[\"production\"] = true\n</code></pre> <p>Disables private member access enforcement, method call depth tracking, and ambiguous member access checks.</p> <p>When to use:</p> <ul> <li>In production/release builds</li> <li>When you've tested thoroughly in development mode</li> <li>When performance is critical</li> </ul>"},{"location":"reference/config/#exposesyntax","title":"exposeSyntax","text":"<p>Exposes syntax functions (<code>class</code>, <code>extends</code>, <code>namespace</code>, etc.) as globals.</p> Type <code>boolean</code> Default <code>true</code> <pre><code>simploo.config[\"exposeSyntax\"] = false\n</code></pre> <p>When <code>false</code>, use <code>simploo.syntax.class</code>, <code>simploo.syntax.namespace</code>, etc. You can also toggle at runtime with <code>simploo.syntax.init()</code> and <code>simploo.syntax.destroy()</code>.</p>"},{"location":"reference/config/#classhotswap","title":"classHotswap","text":"<p>Enables hot-reloading of class definitions, updating existing instances when classes are redefined. New members are added to existing instances. Slightly increases memory usage and has a small performance overhead on instance creation.</p> Type <code>boolean</code> Default <code>false</code> <pre><code>simploo.config[\"classHotswap\"] = true\n</code></pre> <p>See Hotswap for details.</p>"},{"location":"reference/config/#baseinstancetable","title":"baseInstanceTable","text":"<p>The table where classes are stored. By default, classes are added to the global table <code>_G</code>. Useful for isolating classes from global scope, sandboxing, or managing multiple independent class registries.</p> Type <code>table</code> Default <code>_G</code> <pre><code>simploo.config[\"baseInstanceTable\"] = myLib\n</code></pre>"},{"location":"reference/config/#basesyntaxtable","title":"baseSyntaxTable","text":"<p>The table where syntax functions (<code>class</code>, <code>namespace</code>, <code>extends</code>, etc.) are exposed. By default, they are added to the global table <code>_G</code>. Useful for isolating syntax from global scope or avoiding conflicts with other libraries.</p> Type <code>table</code> Default <code>_G</code> <pre><code>simploo.config[\"baseSyntaxTable\"] = myLib\n</code></pre> <p>Note: Due to Lua parsing rules, <code>myLib.class \"A\" myLib.extends \"B\" {}</code> doesn't work. Extract to locals for chainable syntax:</p> <pre><code>local class, extends = myLib.class, myLib.extends\nclass \"Player\" extends \"Entity\" {}\n</code></pre>"},{"location":"reference/config/#custommodifiers","title":"customModifiers","text":"<p>Define custom modifier keywords for class members. Custom modifiers are markers only - implement behavior via hooks.</p> Type <code>table</code> (array of strings) Default <code>{}</code> <pre><code>simploo.config[\"customModifiers\"] = {\"observable\", \"cached\"}\n</code></pre> <p>After defining, use them like built-in modifiers:</p> <pre><code>class \"Model\" {\n    observable {\n        value = 0;\n    };\n}\n</code></pre> <p>Custom modifiers are markers only - implement their behavior via hooks.</p>"},{"location":"reference/config/#strictinterfaces","title":"strictInterfaces","text":"<p>When enabled, interface validation also checks that implementing methods have matching argument count, names, and varargs.</p> Type <code>boolean</code> Default <code>false</code> <pre><code>simploo.config[\"strictInterfaces\"] = true\n</code></pre> <p>Note: Requires Lua 5.2+. On Lua 5.1, this setting has no effect because the debug library cannot inspect function arguments without calling the function.</p> <p>See Interfaces - Strict Interface Checking for details.</p>"},{"location":"reference/config/#configuration-summary","title":"Configuration Summary","text":"Option Type Default Description <code>production</code> boolean <code>false</code> Disable safety checks for performance <code>exposeSyntax</code> boolean <code>true</code> Expose syntax as globals <code>classHotswap</code> boolean <code>false</code> Enable class hot-reloading <code>baseInstanceTable</code> table <code>_G</code> Where classes are stored <code>baseSyntaxTable</code> table <code>_G</code> Where syntax functions are exposed <code>customModifiers</code> table <code>{}</code> Custom modifier keywords <code>strictInterfaces</code> boolean <code>false</code> Check interface method signatures (Lua 5.2+)"},{"location":"reference/config/#recommended-settings","title":"Recommended Settings","text":""},{"location":"reference/config/#development","title":"Development","text":"<pre><code>simploo.config[\"production\"] = false\nsimploo.config[\"classHotswap\"] = true\n</code></pre>"},{"location":"reference/config/#production_1","title":"Production","text":"<pre><code>simploo.config[\"production\"] = true\nsimploo.config[\"classHotswap\"] = false\n</code></pre>"},{"location":"reference/config/#librarymodule-use-only-usually-not-a-thing","title":"Library/Module use only (usually not a thing..)","text":"<pre><code>local myLib = {}\nsimploo.config[\"baseInstanceTable\"] = myLib\nsimploo.config[\"baseSyntaxTable\"] = myLib\nsimploo.config[\"exposeSyntax\"] = false\n</code></pre>"},{"location":"reference/hooks/","title":"Hooks","text":"<p>Hooks let you extend SIMPLOO's behavior by running custom code at specific points.</p>"},{"location":"reference/hooks/#adding-a-hook","title":"Adding a Hook","text":"<pre><code>simploo.hook:add(\"hookName\", function(...)\n    -- Your code here\n    return modifiedValue  -- Optional: return to modify the value\nend)\n</code></pre>"},{"location":"reference/hooks/#removing-a-hook","title":"Removing a Hook","text":"<pre><code>-- Remove a specific hook by its callback function\nlocal myHook = function(instance) ... end\nsimploo.hook:add(\"afterNew\", myHook)\nsimploo.hook:remove(\"afterNew\", myHook)\n\n-- Remove all hooks for an event\nsimploo.hook:remove(\"afterNew\")\n</code></pre>"},{"location":"reference/hooks/#available-hooks","title":"Available Hooks","text":""},{"location":"reference/hooks/#beforeregister","title":"beforeRegister","text":"<p>Called before a class or interface is registered. Allows modifying the definition.</p> <p>Arguments:</p> <ul> <li><code>data</code> - The parsed class/interface data table (check <code>data.type</code> for <code>\"class\"</code> or <code>\"interface\"</code>)</li> </ul> <p>Returns:</p> <ul> <li>Modified <code>data</code> (optional)</li> </ul> <pre><code>simploo.hook:add(\"beforeRegister\", function(data)\n    print(\"Creating \" .. data.type .. \": \" .. data.name)\n\n    if data.type == \"class\" then\n        -- Modify class data\n        data.members.createdAt = {\n            value = os.time(),\n            modifiers = {public = true}\n        }\n    end\n\n    return data\nend)\n</code></pre> <p>data structure:</p> <pre><code>{\n    type = \"class\",  -- or \"interface\"\n    name = \"ClassName\",\n    parents = {\"Parent1\", \"Parent2\"},\n    members = {\n        memberName = {\n            value = &lt;value&gt;,\n            modifiers = {public = true, static = false, ...}\n        }\n    },\n    usings = {...},\n    resolved_usings = {...}\n}\n</code></pre>"},{"location":"reference/hooks/#afterregister","title":"afterRegister","text":"<p>Called after a class or interface is fully registered.</p> <p>Arguments:</p> <ul> <li><code>data</code> - The parsed class/interface data</li> <li><code>baseInstance</code> - The created class/interface instance</li> </ul> <pre><code>simploo.hook:add(\"afterRegister\", function(data, baseInstance)\n    print(data.type .. \" registered: \" .. baseInstance:get_name())\nend)\n</code></pre>"},{"location":"reference/hooks/#afternew","title":"afterNew","text":"<p>Called after a new instance is created via <code>new()</code> or <code>deserialize()</code>.</p> <p>Arguments:</p> <ul> <li><code>instance</code> - The newly created instance</li> </ul> <p>Returns:</p> <ul> <li>Modified or replacement instance (optional)</li> </ul> <pre><code>simploo.hook:add(\"afterNew\", function(instance)\n    print(\"New instance of: \" .. instance:get_name())\n\n    -- Track all instances\n    allInstances = allInstances or {}\n    table.insert(allInstances, instance)\n\n    return instance\nend)\n</code></pre>"},{"location":"reference/hooks/#onnamespace","title":"onNamespace","text":"<p>Called when <code>namespace</code> is used.</p> <p>Arguments:</p> <ul> <li><code>namespaceName</code> - The namespace string</li> </ul> <p>Returns:</p> <ul> <li>Modified namespace name (optional)</li> </ul> <pre><code>simploo.hook:add(\"onNamespace\", function(namespaceName)\n    print(\"Entering namespace: \" .. namespaceName)\n\n    -- Prefix all namespaces\n    return \"myapp.\" .. namespaceName\nend)\n</code></pre>"},{"location":"reference/hooks/#onusing","title":"onUsing","text":"<p>Called when <code>using</code> is used.</p> <p>Arguments:</p> <ul> <li><code>namespaceName</code> - The using path</li> </ul> <p>Returns:</p> <ul> <li>Modified using path (optional)</li> </ul> <pre><code>simploo.hook:add(\"onUsing\", function(namespaceName)\n    print(\"Using: \" .. namespaceName)\n\n    -- Could auto-load the class file here\n    -- loadClassFile(namespaceName)\n\n    return namespaceName\nend)\n</code></pre>"},{"location":"reference/hooks/#firing-hooks","title":"Firing Hooks","text":"<p>SIMPLOO fires hooks internally, but you can also fire them:</p> <pre><code>local result = simploo.hook:fire(\"hookName\", arg1, arg2, ...)\n</code></pre>"},{"location":"reference/hooks/#multiple-hooks","title":"Multiple Hooks","text":"<p>Multiple hooks can be registered for the same event. They run in registration order:</p> <pre><code>simploo.hook:add(\"afterNew\", function(instance)\n    print(\"Hook 1\")\n    return instance\nend)\n\nsimploo.hook:add(\"afterNew\", function(instance)\n    print(\"Hook 2\")\n    return instance\nend)\n\n-- When instance created:\n-- Hook 1\n-- Hook 2\n</code></pre>"},{"location":"reference/hooks/#example-auto-generate-getterssetters","title":"Example: Auto-Generate Getters/Setters","text":"<pre><code>simploo.hook:add(\"beforeRegister\", function(classData)\n    -- Collect names first to avoid modifying table during iteration\n    local memberNames = {}\n    for name in pairs(classData.members) do\n        table.insert(memberNames, name)\n    end\n\n    for _, name in ipairs(memberNames) do\n        local data = classData.members[name]\n\n        if type(data.value) ~= \"function\" and not data.modifiers.private then\n            local upperName = name:sub(1, 1):upper() .. name:sub(2)\n            local getterName = \"get\" .. upperName\n            local setterName = \"set\" .. upperName\n\n            if not classData.members[getterName] then\n                classData.members[getterName] = {\n                    value = function(self)\n                        return self[name]\n                    end,\n                    modifiers = {public = true}\n                }\n            end\n\n            if not classData.members[setterName] then\n                classData.members[setterName] = {\n                    value = function(self, value)\n                        self[name] = value\n                    end,\n                    modifiers = {public = true}\n                }\n            end\n        end\n    end\n\n    return classData\nend)\n\n-- Usage\nclass \"Person\" {\n    name = \"\";\n    age = 0;\n}\n\nlocal p = Person.new()\np:setName(\"Alice\")\np:setAge(30)\nprint(p:getName())  -- Alice\nprint(p:getAge())   -- 30\n</code></pre>"},{"location":"reference/hooks/#example-instance-logging","title":"Example: Instance Logging","text":"<pre><code>-- Note: This holds strong references to instances.\n-- Remove entries when done or use weak references to avoid memory leaks.\nlocal instanceLog = {}\n\nsimploo.hook:add(\"afterNew\", function(instance)\n    table.insert(instanceLog, {\n        class = instance:get_name(),\n        time = os.time(),\n        instance = instance\n    })\n\n    print(string.format(\n        \"[%s] Created %s instance (#%d total)\",\n        os.date(\"%H:%M:%S\"),\n        instance:get_name(),\n        #instanceLog\n    ))\n\n    return instance\nend)\n</code></pre>"},{"location":"reference/hooks/#example-auto-load-dependencies","title":"Example: Auto-Load Dependencies","text":"<pre><code>simploo.hook:add(\"onUsing\", function(path)\n    -- Convert namespace path to file path\n    local filePath = \"classes/\" .. path:gsub(\"%.\", \"/\") .. \".lua\"\n\n    -- Check if class exists, if not try to load it\n    local class = simploo.config[\"baseInstanceTable\"][path]\n    if not class then\n        local file = io.open(filePath, \"r\")\n        if file then\n            file:close()\n            dofile(filePath)\n            print(\"Auto-loaded: \" .. filePath)\n        end\n    end\n\n    return path\nend)\n</code></pre>"},{"location":"reference/hooks/#example-networked-variables","title":"Example: Networked Variables","text":"<p>This example shows how to intercept member value changes using a custom modifier. Useful for automatically syncing variables over a network.</p> <pre><code>-- 1. Register custom modifier (set before loading simploo, or before first class definition)\nsimploo.config[\"customModifiers\"] = {\"replicated\"}\n\n-- 2. Define interface with default handler\ninterface \"Replicated\" {\n    default {\n        onReplicate = function(self, name, old, new)\n            -- Default implementation\n            print(string.format(\"[NET DEFAULT] %s: %s -&gt; %s\", name, old, new))\n        end;\n    };\n}\n\n-- 3. Hook to set up watchers on replicated members\nsimploo.hook:add(\"afterNew\", function(instance)\n    if not instance:instance_of(Replicated) then\n        return instance\n    end\n\n    for name, memberInfo in pairs(instance:get_members()) do\n        if memberInfo.modifiers.replicated then\n            -- Get the actual member table (not a copy)\n            local member = instance._members[name]\n            -- Proxy pattern: move value to storage, intercept via metatable\n            local storage = {value = member.value}\n            member.value = nil\n            setmetatable(member, {\n                __index = function(t, k)\n                    if k == \"value\" then return storage.value end\n                    return rawget(t, k)\n                end,\n                __newindex = function(t, k, v)\n                    if k == \"value\" then\n                        instance:onReplicate(name, storage.value, v)\n                        storage.value = v\n                    else\n                        rawset(t, k, v)\n                    end\n                end\n            })\n        end\n    end\n    return instance\nend)\n\n-- 4. Use it with default handler\nclass \"Player\" implements \"Replicated\" {\n    public {\n        name = \"unnamed\";\n    };\n    replicated {\n        health = 100;\n    };\n}\n\nlocal p = Player()\np.name = \"Bob\"      -- no output\np.health = 50       -- prints: [NET DEFAULT] health: 100 -&gt; 50\n\n-- 5. Or override the handler\nclass \"Enemy\" implements \"Replicated\" {\n    replicated {\n        health = 50;\n    };\n\n    onReplicate = function(self, name, old, new)\n        -- Custom logic: send to server\n        print(string.format(\"[NET CUSTOM] %s: %s -&gt; %s\", name, old, new))\n    end;\n}\n</code></pre> <p>Note: The <code>get_member()</code> and <code>get_members()</code> methods used above are documented in Instance Methods.</p>"},{"location":"reference/instance-methods/","title":"Instance Methods","text":"<p>Every SIMPLOO instance has these built-in methods available.</p>"},{"location":"reference/instance-methods/#get_name","title":"get_name()","text":"<p>Returns the full class name as a string.</p> <pre><code>class \"Player\" {}\n\nlocal p = Player.new()\nprint(p:get_name())  -- Player\n</code></pre> <p>With namespaces:</p> <pre><code>namespace \"game.entities\"\n\nclass \"Enemy\" {}\n\nlocal e = game.entities.Enemy.new()\nprint(e:get_name())  -- game.entities.Enemy\n</code></pre>"},{"location":"reference/instance-methods/#get_class","title":"get_class()","text":"<p>Returns the base class of the instance.</p> <pre><code>class \"Player\" {}\n\nlocal p = Player.new()\nprint(p:get_class() == Player)  -- true\n</code></pre>"},{"location":"reference/instance-methods/#instance_ofother","title":"instance_of(other)","text":"<p>Checks if the instance is derived from another class. Works with inheritance chains.</p> <p>Arguments:</p> <ul> <li><code>other</code> - A class, instance, or class name string to check against</li> </ul> <p>Returns:</p> <ul> <li><code>true</code> if this instance is of the given class or inherits from it</li> <li><code>false</code> otherwise</li> </ul> <pre><code>class \"Animal\" {}\nclass \"Mammal\" extends \"Animal\" {}\nclass \"Dog\" extends \"Mammal\" {}\nclass \"Cat\" extends \"Mammal\" {}\n\nlocal dog = Dog.new()\nlocal cat = Cat.new()\n\n-- Direct class\nprint(dog:instance_of(Dog))     -- true\n\n-- Parent classes\nprint(dog:instance_of(Mammal))  -- true\nprint(dog:instance_of(Animal))  -- true\n\n-- Different class\nprint(dog:instance_of(Cat))     -- false\n\n-- Works with instances too\nlocal someAnimal = Animal.new()\nprint(dog:instance_of(someAnimal))  -- true\n\n-- Works with string names too\nprint(dog:instance_of(\"Dog\"))     -- true\nprint(dog:instance_of(\"Animal\"))  -- true\nprint(dog:instance_of(\"Unknown\")) -- false (returns false, not error)\n</code></pre>"},{"location":"reference/instance-methods/#checking-multiple-types","title":"Checking Multiple Types","text":"<pre><code>class \"Flyable\" {}\nclass \"Swimmable\" {}\nclass \"Duck\" extends \"Flyable, Swimmable\" {}\n\nlocal duck = Duck.new()\n\nprint(duck:instance_of(Flyable))    -- true\nprint(duck:instance_of(Swimmable))  -- true\n</code></pre>"},{"location":"reference/instance-methods/#checking-interfaces","title":"Checking Interfaces","text":"<p>Works with interfaces too:</p> <pre><code>interface \"Damageable\" {\n    takeDamage = function(self, amount) end;\n}\n\nclass \"Player\" implements \"Damageable\" {\n    takeDamage = function(self, amount) end;\n}\n\nclass \"Wall\" {}\n\nlocal player = Player.new()\nlocal wall = Wall.new()\n\nprint(player:instance_of(Damageable))  -- true\nprint(wall:instance_of(Damageable))    -- false\n</code></pre>"},{"location":"reference/instance-methods/#inverse-check","title":"Inverse Check","text":"<p>To check if a class is a parent of an instance:</p> <pre><code>class \"Vehicle\" {}\nclass \"Car\" extends \"Vehicle\" {}\n\nlocal car = Car.new()\nlocal vehicle = Vehicle.new()\n\nprint(car:instance_of(Vehicle))      -- true (car is a vehicle)\nprint(vehicle:instance_of(Car))      -- false (vehicle is not a car)\n</code></pre>"},{"location":"reference/instance-methods/#get_parents","title":"get_parents()","text":"<p>Returns a table of parent instances.</p> <pre><code>class \"A\" {}\nclass \"B\" {}\nclass \"C\" extends \"A, B\" {}\n\nlocal c = C.new()\nlocal parents = c:get_parents()\n\n-- Access parent instances\nprint(parents.A)  -- parent A instance\nprint(parents.B)  -- parent B instance\n</code></pre>"},{"location":"reference/instance-methods/#get_membername","title":"get_member(name)","text":"<p>Returns the internal member table for a given member name. Useful for hooks that need to inspect or modify member behavior.</p> <p>Arguments:</p> <ul> <li><code>name</code> - The member name</li> </ul> <p>Returns:</p> <ul> <li>Member table <code>{value, owner, modifiers}</code> or <code>nil</code> if not found</li> </ul> <pre><code>class \"Player\" {\n    public { health = 100 };\n}\n\nlocal p = Player.new()\nlocal member = p:get_member(\"health\")\n\nprint(member.value)              -- 100\nprint(member.modifiers.public)   -- true\n</code></pre>"},{"location":"reference/instance-methods/#get_members","title":"get_members()","text":"<p>Returns a table of all members (excludes parent references).</p> <p>Returns:</p> <ul> <li>Table <code>{memberName = member, ...}</code> where each member has <code>{value, owner, modifiers}</code></li> </ul> <pre><code>class \"Player\" {\n    public { \n        health = 100;\n        name = \"unnamed\";\n    };\n}\n\nlocal p = Player.new()\nfor name, member in pairs(p:get_members()) do\n    print(name, member.value)\nend\n-- health  100\n-- name    unnamed\n</code></pre>"},{"location":"reference/instance-methods/#bindfn","title":"bind(fn)","text":"<p>Wraps a callback so it can access private/protected members.</p> <p>Most code doesn't need this. You only need <code>bind()</code> when you pass a callback to another class and that callback accesses private/protected members.</p> <pre><code>class \"Emitter\" {\n    public {\n        onEvent = function(self, callback)\n            callback()\n        end\n    }\n}\n\nclass \"Player\" {\n    private { health = 100 };\n\n    public {\n        setup = function(self, emitter)\n            -- Without bind\n            emitter:onEvent(function()\n                print(self.health)  -- ERROR: \"accessing private member health\"\n            end)\n\n            -- With bind\n            emitter:onEvent(self:bind(function()\n                print(self.health)  -- OK\n            end))\n        end\n    }\n}\n</code></pre> <p>If your callback only uses public members, you don't need <code>bind()</code>.</p>"},{"location":"reference/instance-methods/#clone","title":"clone()","text":"<p>Creates a deep copy of the instance. Faster than serialize/deserialize and includes transient members.</p> <p>Returns:</p> <ul> <li>A new instance with the same member values</li> </ul> <pre><code>class \"Player\" {\n    name = \"\";\n    health = 100;\n    inventory = {};\n\n    transient { lastUpdate = 0 };\n}\n\nlocal player = Player.new()\nplayer.name = \"Alice\"\nplayer.health = 75\nplayer.inventory = {\"sword\", \"shield\"}\nplayer.lastUpdate = os.time()\n\nlocal cloned = player:clone()\n\n-- Values are copied\nprint(cloned.name)       -- Alice\nprint(cloned.health)     -- 75\nprint(#cloned.inventory) -- 2\n\n-- Unlike deserialize, transient members are included\nprint(cloned.lastUpdate) -- (same as player.lastUpdate)\n\n-- Clone is independent - changes don't affect original\ncloned.health = 100\nprint(player.health) -- 75 (unchanged)\n</code></pre>"},{"location":"reference/instance-methods/#clone-vs-serializedeserialize","title":"clone() vs serialize/deserialize","text":"Feature <code>clone()</code> <code>serialize()</code> + <code>deserialize()</code> Speed Faster Slower (converts to/from table) Transient members Included Reset to defaults Use case In-memory copies Saving/loading data"},{"location":"reference/instance-methods/#static-members","title":"Static Members","text":"<p>Static members are shared, not copied:</p> <pre><code>class \"Counter\" {\n    public { instanceId = 0 };\n    static { totalCount = 0 };\n}\n\nlocal a = Counter.new()\na.instanceId = 1\n\nlocal b = a:clone()\nb.instanceId = 2\n\n-- Instance values are independent\nprint(a.instanceId) -- 1\nprint(b.instanceId) -- 2\n\n-- Static values are shared\nb.totalCount = 10\nprint(a.totalCount) -- 10\n</code></pre>"},{"location":"reference/instance-methods/#summary","title":"Summary","text":"Method Returns Description <code>get_name()</code> string Full class name <code>get_class()</code> class Base class reference <code>instance_of(other)</code> boolean Inheritance check <code>get_parents()</code> table Parent instances <code>get_member(name)</code> table/nil Member table <code>{value, owner, modifiers}</code> <code>get_members()</code> table All members (excludes parent refs) <code>bind(fn)</code> function Bind callback to current scope <code>clone()</code> instance Deep copy of instance"},{"location":"reference/modifiers/","title":"Modifiers Reference","text":"<p>Complete list of all modifiers available in SIMPLOO.</p> Modifier Description See <code>public</code> Accessible from anywhere (default) Access Control <code>private</code> Only accessible within the declaring class Access Control <code>protected</code> Accessible within class and subclasses Access Control <code>static</code> Shared across all instances Statics <code>const</code> Cannot be modified after initialization Members <code>transient</code> Excluded from serialization Serialization <code>meta</code> Marks a method as a Lua metamethod Metamethods <code>default</code> Interface method with default implementation Interfaces"},{"location":"reference/modifiers/#combining-modifiers","title":"Combining Modifiers","text":"<p>Modifiers can be combined by nesting:</p> Block SyntaxBuilder Syntax <pre><code>class \"Example\" {\n    private {\n        static {\n            const {\n                SECRET = \"abc123\";\n            };\n        };\n    };\n}\n</code></pre> <pre><code>local example = class(\"Example\")\nexample.private.static.const.SECRET = \"abc123\"\nexample:register()\n</code></pre>"},{"location":"reference/modifiers/#modifier-compatibility","title":"Modifier Compatibility","text":"Combination Valid Notes <code>private static</code> Yes Private class-level member <code>public const</code> Yes Read-only public member <code>static const</code> Yes Class-level constant <code>private static const</code> Yes Private class-level constant <code>static transient</code> Yes Not serialized, shared <code>default</code> (in interface) Yes Only valid in interfaces <code>private</code> (in interface) No Interfaces only allow public methods <code>static</code> (in interface) No Interfaces cannot have static methods"}]}